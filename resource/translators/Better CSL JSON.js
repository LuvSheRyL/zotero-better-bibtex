// Generated by CoffeeScript 1.10.0
var doExport;

doExport = function() {
  var citekey, creator, creators, fields, i, item, items, json, k, len, name, ref, ref1, ref2, swap, v, value;
  items = [];
  while (item = Zotero.nextItem()) {
    if (item.itemType === 'note' || item.itemType === 'attachment') {
      continue;
    }
    Zotero.BetterBibTeX.keymanager.extract(item, 'nextItem');
    fields = Translator.extractFields(item);
    json = Zotero.Utilities.itemToCSLJSON(item);
    if (json.issued && item.date) {
      json.issued = Zotero.BetterBibTeX.parseDateToArray(item.date);
    }
    for (name in fields) {
      value = fields[name];
      if (value.format !== 'csl') {
        continue;
      }
      switch (Translator.CSLVariables[name].type) {
        case 'date':
          json[name] = Zotero.BetterBibTeX.parseDateToArray(value.value);
          break;
        case 'creator':
          creators = [];
          ref = value.value;
          for (i = 0, len = ref.length; i < len; i++) {
            creator = ref[i];
            creator = {
              family: creator.lastName || '',
              given: creator.firstName || ''
            };
            Zotero.BetterBibTeX.CSL.parseParticles(creator);
            creators.push(creator);
          }
          json[name] = creators;
          break;
        default:
          json[name] = value.value;
      }
    }
    swap = {
      shortTitle: 'title-short',
      journalAbbreviation: 'container-title-short'
    };
    if ((ref1 = json.type) === 'motion_picture' || ref1 === 'broadcast') {
      swap.author = 'director';
    }
    for (k in swap) {
      v = swap[k];
      ref2 = [json[v], json[k]], json[k] = ref2[0], json[v] = ref2[1];
    }
    citekey = json.id = Zotero.BetterBibTeX.keymanager.get(item, 'on-export').citekey;
    json = JSON.stringify(json);
    Zotero.BetterBibTeX.cache.store(item.itemID, Translator.header, citekey, json);
    items.push(json);
  }
  items = "[\n" + ((function() {
    var j, len1, results;
    results = [];
    for (j = 0, len1 = items.length; j < len1; j++) {
      item = items[j];
      results.push("  " + item);
    }
    return results;
  })()).join(",\n") + "\n]\n";
  return Zotero.write(items);
};
