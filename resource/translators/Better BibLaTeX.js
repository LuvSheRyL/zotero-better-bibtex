// Generated by CoffeeScript 1.10.0
var DateField, Language, doExport,
  hasProp = {}.hasOwnProperty;

Translator.fieldMap = {
  place: {
    name: 'location',
    enc: 'literal'
  },
  chapter: {
    name: 'chapter',
    preserveCaps: true
  },
  edition: {
    name: 'edition',
    preserveCaps: true
  },
  title: {
    name: 'title',
    preserveCaps: true
  },
  volume: {
    name: 'volume',
    preserveCaps: true
  },
  rights: {
    name: 'rights',
    preserveCaps: true
  },
  ISBN: {
    name: 'isbn'
  },
  ISSN: {
    name: 'issn'
  },
  url: {
    name: 'url'
  },
  DOI: {
    name: 'doi'
  },
  shortTitle: {
    name: 'shorttitle',
    preserveCaps: true
  },
  abstractNote: {
    name: 'abstract'
  },
  numberOfVolumes: {
    name: 'volumes'
  },
  versionNumber: {
    name: 'version'
  },
  conferenceName: {
    name: 'eventtitle',
    preserveCaps: true
  },
  numPages: {
    name: 'pagetotal'
  },
  type: {
    name: 'type'
  }
};

Translator.typeMap = {
  'book booklet manual proceedings': 'book',
  'incollection inbook': 'bookSection',
  'article misc': 'journalArticle magazineArticle newspaperArticle',
  thesis: 'thesis',
  letter: 'email letter',
  movie: 'film',
  artwork: 'artwork',
  '=online': 'blogPost forumPost webpage',
  inproceedings: 'conferencePaper',
  report: 'report',
  legislation: 'statute bill',
  jurisdiction: 'case hearing',
  patent: 'patent',
  audio: 'audioRecording podcast radioBroadcast',
  video: 'videoRecording tvBroadcast',
  software: 'computerProgram',
  unpublished: 'manuscript presentation',
  inreference: 'encyclopediaArticle dictionaryEntry',
  misc: 'interview map instantMessage document'
};

Translator.fieldEncoding = {
  url: 'url',
  doi: 'verbatim',
  eprint: 'verbatim',
  eprintclass: 'verbatim',
  crossref: 'raw',
  xdata: 'raw',
  xref: 'raw',
  entrykey: 'raw',
  childentrykey: 'raw',
  verba: 'verbatim',
  verbb: 'verbatim',
  verbc: 'verbatim'
};

Language = new ((function() {
  function _Class() {
    var j, k, key, lang, len, ref1, ref2, v, value;
    this.babelMap = {
      af: 'afrikaans',
      am: 'amharic',
      ar: 'arabic',
      ast: 'asturian',
      bg: 'bulgarian',
      bn: 'bengali',
      bo: 'tibetan',
      br: 'breton',
      ca: 'catalan',
      cop: 'coptic',
      cy: 'welsh',
      cz: 'czech',
      da: 'danish',
      de_1996: 'ngerman',
      de_at_1996: 'naustrian',
      de_at: 'austrian',
      de_de_1996: 'ngerman',
      de: ['german', 'germanb'],
      dsb: ['lsorbian', 'lowersorbian'],
      dv: 'divehi',
      el: 'greek',
      el_polyton: 'polutonikogreek',
      en_au: 'australian',
      en_ca: 'canadian',
      en: 'english',
      en_gb: ['british', 'ukenglish'],
      en_nz: 'newzealand',
      en_us: ['american', 'usenglish'],
      eo: 'esperanto',
      es: 'spanish',
      et: 'estonian',
      eu: 'basque',
      fa: 'farsi',
      fi: 'finnish',
      fr_ca: ['acadian', 'canadian', 'canadien'],
      fr: ['french', 'francais'],
      fur: 'friulan',
      ga: 'irish',
      gd: ['scottish', 'gaelic'],
      gl: 'galician',
      he: 'hebrew',
      hi: 'hindi',
      hr: 'croatian',
      hsb: ['usorbian', 'uppersorbian'],
      hu: 'magyar',
      hy: 'armenian',
      ia: 'interlingua',
      id: ['indonesian', 'bahasa', 'bahasai', 'indon', 'meyalu'],
      is: 'icelandic',
      it: 'italian',
      ja: 'japanese',
      kn: 'kannada',
      la: 'latin',
      lo: 'lao',
      lt: 'lithuanian',
      lv: 'latvian',
      ml: 'malayalam',
      mn: 'mongolian',
      mr: 'marathi',
      nb: ['norsk', 'bokmal'],
      nl: 'dutch',
      nn: 'nynorsk',
      no: ['norwegian', 'norsk'],
      oc: 'occitan',
      pl: 'polish',
      pms: 'piedmontese',
      pt_br: ['brazil', 'brazilian'],
      pt: ['portuguese', 'portuges'],
      pt_pt: 'portuguese',
      rm: 'romansh',
      ro: 'romanian',
      ru: 'russian',
      sa: 'sanskrit',
      se: 'samin',
      sk: 'slovak',
      sl: ['slovenian', 'slovene'],
      sq_al: 'albanian',
      sr_cyrl: 'serbianc',
      sr_latn: 'serbian',
      sr: 'serbian',
      sv: 'swedish',
      syr: 'syriac',
      ta: 'tamil',
      te: 'telugu',
      th: ['thai', 'thaicjk'],
      tk: 'turkmen',
      tr: 'turkish',
      uk: 'ukrainian',
      ur: 'urdu',
      vi: 'vietnamese',
      zh_latn: 'pinyin',
      zh: 'pinyin',
      zlm: ['malay', 'bahasam', 'melayu']
    };
    ref1 = this.babelMap;
    for (key in ref1) {
      if (!hasProp.call(ref1, key)) continue;
      value = ref1[key];
      if (typeof value === 'string') {
        this.babelMap[key] = [value];
      }
    }
    this.babelList = [];
    ref2 = this.babelMap;
    for (k in ref2) {
      if (!hasProp.call(ref2, k)) continue;
      v = ref2[k];
      for (j = 0, len = v.length; j < len; j++) {
        lang = v[j];
        if (this.babelList.indexOf(lang) < 0) {
          this.babelList.push(lang);
        }
      }
    }
    this.cache = Object.create(null);
  }

  return _Class;

})());

Language.get_bigrams = function(string) {
  var i, s;
  s = string.toLowerCase();
  s = (function() {
    var j, ref1, results;
    results = [];
    for (i = j = 0, ref1 = s.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
      results.push(s.slice(i, i + 2));
    }
    return results;
  })();
  s.sort();
  return s;
};

Language.string_similarity = function(str1, str2) {
  var hit_count, pairs1, pairs2, union;
  pairs1 = this.get_bigrams(str1);
  pairs2 = this.get_bigrams(str2);
  union = pairs1.length + pairs2.length;
  hit_count = 0;
  while (pairs1.length > 0 && pairs2.length > 0) {
    if (pairs1[0] === pairs2[0]) {
      hit_count++;
      pairs1.shift();
      pairs2.shift();
      continue;
    }
    if (pairs1[0] < pairs2[0]) {
      pairs1.shift();
    } else {
      pairs2.shift();
    }
  }
  return (2 * hit_count) / union;
};

Language.lookup = function(langcode) {
  var j, lc, len, ref1;
  if (!this.cache[langcode]) {
    this.cache[langcode] = [];
    ref1 = Language.babelList;
    for (j = 0, len = ref1.length; j < len; j++) {
      lc = ref1[j];
      this.cache[langcode].push({
        lang: lc,
        sim: this.string_similarity(langcode, lc)
      });
    }
    this.cache[langcode].sort(function(a, b) {
      return b.sim - a.sim;
    });
  }
  return this.cache[langcode];
};

DateField = (function() {
  function DateField(date, locale, formatted, literal) {
    var parsed;
    parsed = Zotero.BetterBibTeX.parseDateToObject(date, locale);
    switch (false) {
      case !!parsed:
        this.field = {};
        break;
      case !parsed.literal:
        this.field = {
          name: literal,
          value: date
        };
        break;
      case !((parsed.year || parsed.empty) && (parsed.year_end || parsed.empty_end)):
        this.field = {
          name: formatted,
          value: this.format(parsed) + '/' + this.format(parsed, '_end')
        };
        break;
      case !parsed.year:
        this.field = {
          name: formatted,
          value: this.format(parsed)
        };
        break;
      default:
        this.field = {};
    }
  }

  DateField.prototype.pad = function(v, pad) {
    if (v.length >= pad.length) {
      return v;
    }
    return (pad + v).slice(-pad.length);
  };

  DateField.prototype.format = function(v, suffix) {
    var _v, f, j, len, ref1;
    if (suffix == null) {
      suffix = '';
    }
    _v = {};
    ref1 = ['empty', 'year', 'month', 'day'];
    for (j = 0, len = ref1.length; j < len; j++) {
      f = ref1[j];
      _v[f] = v["" + f + suffix];
    }
    if (_v.empty) {
      return '';
    }
    if (_v.year && _v.month && _v.day) {
      return _v.year + "-" + (this.pad(_v.month, '00')) + "-" + (this.pad(_v.day, '00'));
    }
    if (_v.year && _v.month) {
      return _v.year + "-" + (this.pad(_v.month, '00'));
    }
    return '' + _v.year;
  };

  return DateField;

})();

doExport = function() {
  var abbr, archive, creator, creators, eprinttype, field, item, j, l, langlc, language, len, len1, len2, m, n, name, note, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, sim, thesistype, value;
  Zotero.write('\n');
  while (item = Translator.nextItem()) {
    ref = new Reference(item);
    if (item.itemType === 'bookSection' && ref.hasCreator('bookAuthor')) {
      ref.referencetype = 'inbook';
    }
    if (item.itemType === 'book' && !ref.hasCreator('author') && ref.hasCreator('editor')) {
      ref.referencetype = 'collection';
    }
    if (ref.referencetype === 'book' && item.numberOfVolumes) {
      ref.referencetype = 'mvbook';
    }
    if (m = (ref1 = item.publicationTitle) != null ? ref1.match(/^arxiv:\s*([\S]+)/i) : void 0) {
      ref.add({
        name: 'eprinttype',
        value: 'arxiv'
      });
      ref.add({
        name: 'eprint',
        value: m[1]
      });
      delete item.publicationTitle;
    }
    if (m = (ref2 = item.url) != null ? ref2.match(/^http:\/\/www.jstor.org\/stable\/([\S]+)$/i) : void 0) {
      ref.add({
        name: 'eprinttype',
        value: 'jstor'
      });
      ref.add({
        name: 'eprint',
        value: m[1]
      });
      delete item.url;
      ref.remove('url');
    }
    if (m = (ref3 = item.url) != null ? ref3.match(/^http:\/\/books.google.com\/books?id=([\S]+)$/i) : void 0) {
      ref.add({
        name: 'eprinttype',
        value: 'googlebooks'
      });
      ref.add({
        name: 'eprint',
        value: m[1]
      });
      delete item.url;
      ref.remove('url');
    }
    if (m = (ref4 = item.url) != null ? ref4.match(/^http:\/\/www.ncbi.nlm.nih.gov\/pubmed\/([\S]+)$/i) : void 0) {
      ref.add({
        name: 'eprinttype',
        value: 'pubmed'
      });
      ref.add({
        name: 'eprint',
        value: m[1]
      });
      delete item.url;
      ref.remove('url');
    }
    ref5 = ['pmid', 'arxiv', 'jstor', 'hdl', 'googlebooks'];
    for (j = 0, len = ref5.length; j < len; j++) {
      eprinttype = ref5[j];
      if (ref.has[eprinttype]) {
        if (!ref.has.eprinttype) {
          ref.add({
            name: 'eprinttype',
            value: eprinttype
          });
          ref.add({
            name: 'eprint',
            value: ref.has[eprinttype].value
          });
        }
        ref.remove(eprinttype);
      }
    }
    if (item.archive && item.archiveLocation) {
      archive = true;
      switch (item.archive.toLowerCase()) {
        case 'arxiv':
          if (!ref.has.eprinttype) {
            ref.add({
              name: 'eprinttype',
              value: 'arxiv'
            });
          }
          ref.add({
            name: 'eprintclass',
            value: item.callNumber
          });
          break;
        case 'jstor':
          if (!ref.has.eprinttype) {
            ref.add({
              name: 'eprinttype',
              value: 'jstor'
            });
          }
          break;
        case 'pubmed':
          if (!ref.has.eprinttype) {
            ref.add({
              name: 'eprinttype',
              value: 'pubmed'
            });
          }
          break;
        case 'hdl':
          if (!ref.has.eprinttype) {
            ref.add({
              name: 'eprinttype',
              value: 'hdl'
            });
          }
          break;
        case 'googlebooks':
        case 'google books':
          if (!ref.has.eprinttype) {
            ref.add({
              name: 'eprinttype',
              value: 'googlebooks'
            });
          }
          break;
        default:
          archive = false;
      }
      if (archive) {
        if (!ref.has.eprint) {
          ref.add({
            name: 'eprint',
            value: item.archiveLocation
          });
        }
      }
    }
    ref.add({
      name: 'number',
      value: item.docketNumber || item.publicLawNumber || item.reportNumber || item.seriesNumber || item.patentNumber || item.billNumber || item.episodeNumber || item.number
    });
    ref.add({
      name: (isNaN(parseInt(item.issue)) ? 'issue' : 'number'),
      value: item.issue
    });
    switch (item.itemType) {
      case 'case':
      case 'gazette':
        ref.add({
          name: 'journaltitle',
          value: item.reporter,
          preserveCaps: true,
          preserveBibTeXVariables: true
        });
        break;
      case 'statute':
        ref.add({
          name: 'journaltitle',
          value: item.code,
          preserveCaps: true,
          preserveBibTeXVariables: true
        });
    }
    if (item.publicationTitle) {
      switch (item.itemType) {
        case 'bookSection':
        case 'conferencePaper':
        case 'dictionaryEntry':
        case 'encyclopediaArticle':
          ref.add({
            name: 'booktitle',
            value: item.bookTitle || item.publicationTitle,
            preserveBibTeXVariables: true,
            preserveCaps: true
          });
          break;
        case 'magazineArticle':
        case 'newspaperArticle':
          ref.add({
            name: 'journaltitle',
            value: item.publicationTitle,
            preserveCaps: true,
            preserveBibTeXVariables: true
          });
          if (item.itemType === 'newspaperArticle') {
            ref.add({
              name: 'journalsubtitle',
              value: item.section,
              preserveCaps: true
            });
          }
          break;
        case 'journalArticle':
          if (ref.isBibVar(item.publicationTitle)) {
            ref.add({
              name: 'journaltitle',
              value: item.publicationTitle,
              preserveBibTeXVariables: true
            });
          } else {
            abbr = Zotero.BetterBibTeX.keymanager.journalAbbrev(item);
            if (Translator.useJournalAbbreviation && abbr) {
              ref.add({
                name: 'journal',
                value: abbr,
                preserveBibTeXVariables: true,
                preserveCaps: true
              });
            } else {
              ref.add({
                name: 'journaltitle',
                value: item.publicationTitle,
                preserveCaps: true
              });
              ref.add({
                name: 'shortjournal',
                value: abbr,
                preserveBibTeXVariables: true,
                preserveCaps: true
              });
            }
          }
      }
    }
    if (!ref.has.booktitle) {
      ref.add({
        name: 'booktitle',
        value: item.bookTitle || item.encyclopediaTitle || item.dictionaryTitle || item.proceedingsTitle,
        preserveCaps: true
      });
    }
    ref.add({
      name: ((ref6 = ref.referencetype) === 'movie' || ref6 === 'video' ? 'booktitle' : 'titleaddon'),
      value: item.websiteTitle || item.forumTitle || item.blogTitle || item.programTitle,
      preserveCaps: true
    });
    ref.add({
      name: 'series',
      value: item.seriesTitle || item.series,
      preserveCaps: true
    });
    switch (item.itemType) {
      case 'report':
      case 'thesis':
        ref.add({
          name: 'institution',
          value: item.institution || item.publisher || item.university,
          enc: 'literal'
        });
        break;
      case 'case':
      case 'hearing':
        ref.add({
          name: 'institution',
          value: item.court,
          enc: 'literal'
        });
        break;
      default:
        ref.add({
          name: 'publisher',
          value: item.publisher,
          enc: 'literal'
        });
    }
    switch (item.itemType) {
      case 'letter':
        ref.add({
          name: 'type',
          value: item.letterType || 'Letter',
          replace: true
        });
        break;
      case 'email':
        ref.add({
          name: 'type',
          value: 'E-mail',
          replace: true
        });
        break;
      case 'thesis':
        thesistype = (ref7 = item.thesisType) != null ? ref7.toLowerCase() : void 0;
        if (thesistype === 'phdthesis' || thesistype === 'mastersthesis') {
          ref.referencetype = thesistype;
          ref.remove('type');
        } else {
          ref.add({
            name: 'type',
            value: item.thesisType,
            replace: true
          });
        }
        break;
      case 'report':
        if ((item.type || '').toLowerCase().trim() === 'techreport') {
          ref.referencetype = 'techreport';
        } else {
          ref.add({
            name: 'type',
            value: item.type,
            replace: true
          });
        }
        break;
      default:
        ref.add({
          name: 'type',
          value: item.type || item.websiteType || item.manuscriptType,
          replace: true
        });
    }
    ref.add({
      name: 'howpublished',
      value: item.presentationType || item.manuscriptType
    });
    ref.add({
      name: 'note',
      value: item.meetingName,
      allowDuplicates: true
    });
    if (item.creators && item.creators.length) {
      creators = {
        author: [],
        bookauthor: [],
        commentator: [],
        editor: [],
        editora: [],
        editorb: [],
        holder: [],
        translator: [],
        scriptwriter: [],
        director: []
      };
      ref8 = item.creators;
      for (l = 0, len1 = ref8.length; l < len1; l++) {
        creator = ref8[l];
        switch (creator.creatorType) {
          case 'director':
            if ((ref9 = ref.referencetype) === 'video' || ref9 === 'movie') {
              creators.director.push(creator);
            } else {
              creators.author.push(creator);
            }
            break;
          case 'author':
          case 'interviewer':
          case 'programmer':
          case 'artist':
          case 'podcaster':
          case 'presenter':
            creators.author.push(creator);
            break;
          case 'bookAuthor':
            creators.bookauthor.push(creator);
            break;
          case 'commenter':
            creators.commentator.push(creator);
            break;
          case 'editor':
            creators.editor.push(creator);
            break;
          case 'inventor':
            creators.holder.push(creator);
            break;
          case 'translator':
            creators.translator.push(creator);
            break;
          case 'seriesEditor':
            creators.editorb.push(creator);
            break;
          case 'scriptwriter':
            if ((ref10 = ref.referencetype) === 'video' || ref10 === 'movie') {
              creators.scriptwriter.push(creator);
            } else {
              creators.editora.push(creator);
            }
            break;
          default:
            creators.editora.push(creator);
        }
      }
      for (field in creators) {
        if (!hasProp.call(creators, field)) continue;
        value = creators[field];
        ref.add({
          name: field,
          value: value,
          enc: 'creators'
        });
      }
      if (creators.editora.length > 0) {
        ref.add({
          name: 'editoratype',
          value: 'collaborator'
        });
      }
      if (creators.editorb.length > 0) {
        ref.add({
          name: 'editorbtype',
          value: 'redactor'
        });
      }
    }
    if (item.accessDate && item.url) {
      ref.add({
        name: 'urldate',
        value: Zotero.Utilities.strToISO(item.accessDate)
      });
    }
    ref.add((new DateField(item.date, item.language, 'date', 'year')).field);
    switch (false) {
      case !item.pages:
        ref.add({
          name: 'pages',
          value: item.pages.replace(/[-\u2012-\u2015\u2053]+/g, '--')
        });
        break;
      case !(item.firstPage && item.lastPage):
        ref.add({
          name: 'pages',
          value: item.firstPage + "--" + item.lastPage
        });
        break;
      case !item.firstPage:
        ref.add({
          name: 'pages',
          value: "" + item.firstPage
        });
    }
    if (item.language) {
      langlc = item.language.toLowerCase();
      language = Language.babelMap[langlc.replace(/[^a-z0-9]/, '_')];
      language || (language = Language.babelMap[langlc.replace(/-[a-z]+$/i, '').replace(/[^a-z0-9]/, '_')]);
      if (language) {
        language = language[0];
      } else {
        sim = Language.lookup(langlc);
        if (sim[0].sim >= 0.9) {
          language = sim[0].lang;
        } else {
          language = null;
        }
      }
      ref.add({
        name: 'langid',
        value: language
      });
    }
    ref.add({
      name: (ref.has.note ? 'annotation' : 'note'),
      value: item.extra,
      allowDuplicates: true
    });
    ref.add({
      name: 'keywords',
      value: item.tags,
      enc: 'tags'
    });
    if (item.notes && Translator.exportNotes) {
      ref11 = item.notes;
      for (n = 0, len2 = ref11.length; n < len2; n++) {
        note = ref11[n];
        ref.add({
          name: 'annotation',
          value: Zotero.Utilities.unescapeHTML(note.note),
          allowDuplicates: true
        });
      }
    }
    if (ref.useprefix) {
      ref.add({
        name: 'options',
        value: 'useprefix=true'
      });
    }
    ref.add({
      name: 'file',
      value: item.attachments,
      enc: 'attachments'
    });
    ref12 = ref.override;
    for (name in ref12) {
      if (!hasProp.call(ref12, name)) continue;
      value = ref12[name];
      if (value.format !== 'csl') {
        continue;
      }
      switch (false) {
        case !(name === 'volume-title' && ref.item.itemType === 'book' && ref.has.title):
          ref.add({
            name: 'maintitle',
            value: value.value,
            preserveCaps: true
          });
          ref13 = [ref.has.maintitle.bibtex, ref.has.title.bibtex], ref.has.title.bibtex = ref13[0], ref.has.maintitle.bibtex = ref13[1];
          ref14 = [ref.has.maintitle.value, ref.has.title.value], ref.has.title.value = ref14[0], ref.has.maintitle.value = ref14[1];
          break;
        case !(name === 'volume-title' && ref.item.itemType === 'bookSection' && ref.has.booktitle):
          ref.add({
            name: 'maintitle',
            value: value.value,
            preserveCaps: true
          });
          ref15 = [ref.has.maintitle.bibtex, ref.has.booktitle.bibtex], ref.has.booktitle.bibtex = ref15[0], ref.has.maintitle.bibtex = ref15[1];
          ref16 = [ref.has.maintitle.value, ref.has.booktitle.value], ref.has.booktitle.value = ref16[0], ref.has.maintitle.value = ref16[1];
          break;
        default:
          continue;
      }
      delete ref.override[name];
    }
    ref.complete();
  }
  Translator.exportGroups();
  Zotero.write('\n');
};
