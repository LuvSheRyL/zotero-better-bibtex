// Generated by CoffeeScript 1.10.0
var JabRef, ZoteroItem, attr, base, detectImport, doExport, doImport, f, field, fields, i, len, months, ref1,
  hasProp = {}.hasOwnProperty;

Translator.fieldMap = {
  place: {
    name: 'address',
    "import": 'location'
  },
  section: {
    name: 'chapter'
  },
  edition: {
    name: 'edition'
  },
  type: {
    name: 'type'
  },
  series: {
    name: 'series'
  },
  title: {
    name: 'title',
    autoCase: true
  },
  volume: {
    name: 'volume'
  },
  rights: {
    name: 'copyright'
  },
  ISBN: {
    name: 'isbn'
  },
  ISSN: {
    name: 'issn'
  },
  callNumber: {
    name: 'lccn'
  },
  shortTitle: {
    name: 'shorttitle',
    autoCase: true
  },
  DOI: {
    name: 'doi'
  },
  abstractNote: {
    name: 'abstract'
  },
  country: {
    name: 'nationality'
  },
  language: {
    name: 'language'
  },
  assignee: {
    name: 'assignee'
  },
  issue: {
    "import": 'issue'
  },
  publicationTitle: {
    "import": 'booktitle'
  },
  publisher: {
    "import": ['school', 'institution', 'publisher'],
    enc: 'literal'
  }
};

Translator.typeMap = {
  'book booklet manual proceedings': 'book',
  'incollection inbook': 'bookSection',
  'article misc': 'journalArticle magazineArticle newspaperArticle',
  'phdthesis mastersthesis': 'thesis',
  unpublished: 'manuscript',
  patent: 'patent',
  'inproceedings conference': 'conferencePaper',
  techreport: 'report',
  misc: 'letter interview film artwork webpage'
};

Translator.fieldEncoding = {
  url: 'url',
  doi: 'verbatim'
};

months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];

doExport = function() {
  var authors, collaborators, creator, date, editors, i, item, j, len, len1, note, pages, primaryCreatorType, ref, ref1, ref2, ref3, ref4, ref5, translators;
  Zotero.write('\n');
  while (item = Translator.nextItem()) {
    ref = new Reference(item);
    ref.add({
      name: 'number',
      value: item.reportNumber || item.issue || item.seriesNumber || item.patentNumber
    });
    ref.add({
      name: 'urldate',
      value: item.accessDate && item.accessDate.replace(/\s*T?\d+:\d+:\d+.*/, '')
    });
    if (Translator.bibtexURLs) {
      if ((ref1 = ref.referencetype) === 'misc' || ref1 === 'booklet') {
        ref.add({
          name: 'howpublished',
          value: item.url,
          enc: 'url'
        });
      } else {
        ref.add({
          name: 'note',
          allowDuplicates: true,
          value: item.url,
          enc: 'url'
        });
      }
    }
    switch (false) {
      case (ref2 = item.itemType) !== 'bookSection' && ref2 !== 'conferencePaper':
        ref.add({
          name: 'booktitle',
          autoCase: true,
          value: item.publicationTitle,
          preserveBibTeXVariables: true
        });
        break;
      case !ref.isBibVar(item.publicationTitle):
        ref.add({
          name: 'journal',
          value: item.publicationTitle,
          preserveBibTeXVariables: true
        });
        break;
      default:
        ref.add({
          name: 'journal',
          value: Translator.useJournalAbbreviation && Zotero.BetterBibTeX.keymanager.journalAbbrev(item) || item.publicationTitle,
          preserveBibTeXVariables: true
        });
    }
    switch (item.itemType) {
      case 'thesis':
        ref.add({
          name: 'school',
          value: item.publisher
        });
        break;
      case 'report':
        ref.add({
          name: 'institution',
          value: item.publisher
        });
        break;
      default:
        ref.add({
          name: 'publisher',
          value: item.publisher,
          enc: 'literal'
        });
    }
    if (item.itemType === 'thesis' && ((ref3 = item.thesisType) === 'mastersthesis' || ref3 === 'phdthesis')) {
      ref.referencetype = item.thesisType;
      ref.remove('type');
    }
    if (item.creators && item.creators.length) {
      authors = [];
      editors = [];
      translators = [];
      collaborators = [];
      primaryCreatorType = Zotero.Utilities.getCreatorsForType(item.itemType)[0];
      ref4 = item.creators;
      for (i = 0, len = ref4.length; i < len; i++) {
        creator = ref4[i];
        switch (creator.creatorType) {
          case 'editor':
          case 'seriesEditor':
            editors.push(creator);
            break;
          case 'translator':
            translators.push(creator);
            break;
          case primaryCreatorType:
            authors.push(creator);
            break;
          default:
            collaborators.push(creator);
        }
      }
      ref.add({
        name: 'author',
        value: authors,
        enc: 'creators'
      });
      ref.add({
        name: 'editor',
        value: editors,
        enc: 'creators'
      });
      ref.add({
        name: 'translator',
        value: translators,
        enc: 'creators'
      });
      ref.add({
        name: 'collaborator',
        value: collaborators,
        enc: 'creators'
      });
    }
    if (item.date) {
      date = Zotero.BetterBibTeX.parseDateToObject(item.date, item.language);
      if (date.literal || date.year_end) {
        ref.add({
          name: 'year',
          value: item.date
        });
      } else {
        if (date.month) {
          ref.add({
            name: 'month',
            value: months[date.month - 1],
            bare: true
          });
        }
        ref.add({
          name: 'year',
          value: '' + date.year
        });
      }
    }
    ref.add({
      name: 'note',
      value: item.extra,
      allowDuplicates: true
    });
    ref.add({
      name: 'keywords',
      value: item.tags,
      enc: 'tags'
    });
    if (item.pages) {
      pages = item.pages;
      if (!ref.raw) {
        pages = pages.replace(/[-\u2012-\u2015\u2053]+/g, '--');
      }
      ref.add({
        name: 'pages',
        value: pages
      });
    }
    if (item.notes && Translator.exportNotes) {
      ref5 = item.notes;
      for (j = 0, len1 = ref5.length; j < len1; j++) {
        note = ref5[j];
        ref.add({
          name: 'annote',
          value: Zotero.Utilities.unescapeHTML(note.note),
          allowDuplicates: true
        });
      }
    }
    ref.add({
      name: 'file',
      value: item.attachments,
      enc: 'attachments'
    });
    ref.complete();
  }
  Translator.exportGroups();
  Zotero.write('\n');
};

detectImport = function() {
  var bib, e, error, input;
  try {
    input = Zotero.read(102400);
    Translator.log("BBT detect against " + input);
    bib = BetterBibTeXParser.parse(input);
    Translator.log("better-bibtex: detect: " + (bib.references.length > 0));
    return bib.references.length > 0;
  } catch (error) {
    e = error;
    Translator.log("better-bibtex: detect failed: " + e + "\n" + e.stack);
    return false;
  }
};

doImport = function() {
  var bib, coll, data, e, error, i, item, j, len, len1, read, ref, ref1, ref2;
  try {
    Translator.initialize();
    data = '';
    while ((read = Zotero.read(0x100000)) !== false) {
      data += read;
    }
    bib = BetterBibTeXParser.parse(data, {
      raw: Translator.rawImports
    });
    ref1 = bib.references;
    for (i = 0, len = ref1.length; i < len; i++) {
      ref = ref1[i];
      new ZoteroItem(ref);
    }
    ref2 = bib.collections;
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      coll = ref2[j];
      JabRef.importGroup(coll);
    }
    if (bib.errors && bib.errors.length > 0) {
      item = new Zotero.Item('journalArticle');
      item.title = Translator.header.label + " import errors";
      item.extra = JSON.stringify({
        translator: Translator.header.translatorID,
        notimported: bib.errors.join("\n\n")
      });
      return item.complete();
    }
  } catch (error) {
    e = error;
    Translator.log("better-bibtex: import failed: " + e + "\n" + e.stack);
    throw e;
  }
};

JabRef = JabRef != null ? JabRef : {};

JabRef.importGroup = function(group) {
  var child, collection, i, key, len, ref1;
  collection = new Zotero.Collection();
  collection.type = 'collection';
  collection.name = group.name;
  collection.children = (function() {
    var i, len, ref1, results;
    ref1 = group.items;
    results = [];
    for (i = 0, len = ref1.length; i < len; i++) {
      key = ref1[i];
      results.push({
        type: 'item',
        id: key
      });
    }
    return results;
  })();
  ref1 = group.collections;
  for (i = 0, len = ref1.length; i < len; i++) {
    child = ref1[i];
    collection.children.push(JabRef.importGroup(child));
  }
  collection.complete();
  return collection;
};

ZoteroItem = (function() {
  function ZoteroItem(bibtex) {
    var base;
    this.type = Translator.typeMap.BibTeX2Zotero[Zotero.Utilities.trimInternal((bibtex.type || bibtex.__type__).toLowerCase())] || 'journalArticle';
    this.item = new Zotero.Item(this.type);
    this.item.itemID = bibtex.__key__;
    Translator.log("new reference: " + this.item.itemID);
    this.biblatexdata = {};
    if (bibtex.__note__) {
      this.item.notes.push({
        note: ('The following fields were not imported:<br/>' + bibtex.__note__).trim(),
        tags: ['#BBT Import']
      });
    }
    this["import"](bibtex);
    if (Translator.rawImports) {
      if ((base = this.item).tags == null) {
        base.tags = [];
      }
      this.item.tags.push(Translator.rawLaTag);
    }
    this.item.complete();
  }

  return ZoteroItem;

})();

ZoteroItem.prototype.keywordClean = function(k) {
  return k.replace(/^[\s{]+|[}\s]+$/g, '').trim();
};

ZoteroItem.prototype.addToExtra = function(str) {
  if (this.item.extra && this.item.extra !== '') {
    this.item.extra += " \n" + str;
  } else {
    this.item.extra = str;
  }
};

ZoteroItem.prototype.addToExtraData = function(key, value) {
  this.biblatexdata[key] = value;
  if (key.match(/[\[\]=;\r\n]/) || value.match(/[\[\]=;\r\n]/)) {
    this.biblatexdatajson = true;
  }
};

ZoteroItem.prototype.fieldMap = Object.create(null);

ref1 = Translator.fieldMap;
for (attr in ref1) {
  if (!hasProp.call(ref1, attr)) continue;
  field = ref1[attr];
  fields = [];
  if (field.name) {
    fields.push(field.name);
  }
  if (field["import"]) {
    fields = fields.concat(field["import"]);
  }
  for (i = 0, len = fields.length; i < len; i++) {
    f = fields[i];
    if ((base = ZoteroItem.prototype.fieldMap)[f] == null) {
      base[f] = attr;
    }
  }
}

ZoteroItem.prototype["import"] = function(bibtex) {
  var att, biblatexdata, creator, hackyFields, j, k, key, keys, keywords, kw, l, len1, len2, m, month, o, ref2, value;
  hackyFields = [];
  for (field in bibtex) {
    if (!hasProp.call(bibtex, field)) continue;
    value = bibtex[field];
    if (typeof value !== 'number' && !value) {
      continue;
    }
    if (typeof value === 'string') {
      value = Zotero.Utilities.trim(value);
    }
    if (value === '') {
      continue;
    }
    if (this.fieldMap[field]) {
      this.item[this.fieldMap[field]] = value;
      continue;
    }
    switch (field) {
      case '__note__':
      case '__key__':
      case 'type':
      case 'added-at':
      case 'timestamp':
        continue;
      case '__type__':
        if ((ref2 = bibtex.__type__) === 'phdthesis' || ref2 === 'mastersthesis') {
          this.item.thesisType = bibtex.__type__;
        }
        break;
      case 'subtitle':
        if (!this.item.title) {
          this.item.title = '';
        }
        this.item.title = this.item.title.trim();
        value = value.trim();
        if (!/[-–—:!?.;]$/.test(this.item.title) && !/^[-–—:.;¡¿]/.test(value)) {
          this.item.title += ': ';
        } else {
          if (this.item.title.length) {
            this.item.title += ' ';
          }
        }
        this.item.title += value;
        break;
      case 'journal':
        if (this.item.publicationTitle) {
          this.item.journalAbbreviation = value;
        } else {
          this.item.publicationTitle = value;
        }
        break;
      case 'fjournal':
        if (this.item.publicationTitle) {
          this.item.journalAbbreviation = this.item.publicationTitle;
        }
        this.item.publicationTitle = value;
        break;
      case 'author':
      case 'editor':
      case 'translator':
        for (j = 0, len1 = value.length; j < len1; j++) {
          creator = value[j];
          if (!creator) {
            continues;
          }
          if (typeof creator === 'string') {
            creator = Zotero.Utilities.cleanAuthor(creator, field, false);
            if (creator.lastName && !creator.firstName) {
              creator.fieldMode = 1;
            }
          } else {
            creator.creatorType = field;
          }
          this.item.creators.push(creator);
        }
        break;
      case 'institution':
      case 'organization':
        this.item.backupPublisher = value;
        break;
      case 'number':
        switch (this.item.itemType) {
          case 'report':
            this.item.reportNumber = value;
            break;
          case 'book':
          case 'bookSection':
            this.item.seriesNumber = value;
            break;
          case 'patent':
            this.item.patentNumber = value;
            break;
          default:
            this.item.issue = value;
        }
        break;
      case 'month':
        month = months.indexOf(value.toLowerCase());
        if (month >= 0) {
          value = Zotero.Utilities.formatDate({
            month: month
          });
        } else {
          value += ' ';
        }
        if (this.item.date) {
          if (value.indexOf(this.item.date) >= 0) {
            this.item.date = value;
          } else {
            this.item.date = value + this.item.date;
          }
        } else {
          this.item.date = value;
        }
        break;
      case 'year':
        if (this.item.date) {
          if (this.item.date.indexOf(value) < 0) {
            this.item.date += value;
          }
        } else {
          this.item.date = value;
        }
        break;
      case 'date':
        this.item.date = value;
        break;
      case 'pages':
        switch (this.item.itemType) {
          case 'book':
          case 'thesis':
          case 'manuscript':
            this.item.numPages = value;
            break;
          default:
            this.item.pages = value.replace(/--/g, '-');
        }
        break;
      case 'note':
        this.addToExtra(value);
        break;
      case 'url':
      case 'howpublished':
        if (m = value.match(/^(\\url{)(https?:\/\/|mailto:)}$/i)) {
          this.item.url = m[2];
        } else if (field === 'url' || /^(https?:\/\/|mailto:)/i.test(value)) {
          this.item.url = value;
        } else {
          this.addToExtraData(field, value);
        }
        break;
      case 'lastchecked':
      case 'urldate':
        this.item.accessDate = value;
        break;
      case 'keywords':
      case 'keyword':
        keywords = value.split(/[,;]/);
        if (keywords.length === 1) {
          keywords = value.split(/\s+/);
        }
        this.item.tags = (function() {
          var l, len2, results;
          results = [];
          for (l = 0, len2 = keywords.length; l < len2; l++) {
            kw = keywords[l];
            results.push(this.keywordClean(kw));
          }
          return results;
        }).call(this);
        break;
      case 'comment':
      case 'annote':
      case 'review':
      case 'notes':
        this.item.notes.push({
          note: Zotero.Utilities.text2html(value)
        });
        break;
      case 'file':
        for (l = 0, len2 = value.length; l < len2; l++) {
          att = value[l];
          this.item.attachments.push(att);
        }
        break;
      case 'eprint':
      case 'eprinttype':
        this.item["_" + field] = value;
        if (this.item._eprint && this.item._eprinttype) {
          switch (this.item._eprinttype.trim().toLowerCase()) {
            case 'arxiv':
              hackyFields.push("arXiv: " + value);
              break;
            case 'jstor':
              hackyFields.push("JSTOR: " + value);
              break;
            case 'pubmed':
              hackyFields.push("PMID: " + value);
              break;
            case 'hdl':
              hackyFields.push("HDL: " + value);
              break;
            case 'googlebooks':
              hackyFields.push("GoogleBooksID: " + value);
          }
          delete this.item._eprint;
          delete this.item._eprinttype;
        }
        break;
      case 'lccn':
        hackyFields.push("LCCB: " + value);
        break;
      case 'mrnumber':
        hackyFields.push("MR: " + value);
        break;
      case 'zmnumber':
        hackyFields.push("Zbl: " + value);
        break;
      case 'pmid':
        hackyFields.push("PMID: " + value);
        break;
      case 'pmcid':
        hackyFields.push("PMCID: " + value);
        break;
      default:
        this.addToExtraData(field, value);
    }
  }
  if (this.item.itemType === 'conferencePaper' && this.item.publicationTitle && !this.item.proceedingsTitle) {
    this.item.proceedingsTitle = this.item.publicationTitle;
    delete this.item.publicationTitle;
  }
  this.addToExtra("bibtex: " + this.item.itemID);
  keys = Object.keys(this.biblatexdata);
  if (keys.length > 0) {
    if (Translator.testing) {
      keys.sort();
    }
    biblatexdata = (function() {
      switch (false) {
        case !(this.biblatexdatajson && Translator.testing):
          return 'bibtex{' + ((function() {
            var len3, n, results;
            results = [];
            for (n = 0, len3 = keys.length; n < len3; n++) {
              k = keys[n];
              o = {};
              o[k] = this.biblatexdata[k];
              results.push(JSON5.stringify(o).slice(1, -1));
            }
            return results;
          }).call(this)) + '}';
        case !this.biblatexdatajson:
          return "bibtex" + (JSON5.stringify(this.biblatexdata));
        default:
          return biblatexdata = 'bibtex[' + ((function() {
            var len3, n, results;
            results = [];
            for (n = 0, len3 = keys.length; n < len3; n++) {
              key = keys[n];
              results.push(key + "=" + this.biblatexdata[key]);
            }
            return results;
          }).call(this)).join(';') + ']';
      }
    }).call(this);
    this.addToExtra(biblatexdata);
  }
  if (hackyFields.length > 0) {
    hackyFields.sort();
    this.addToExtra(hackyFields.join(" \n"));
  }
  if (!this.item.publisher && this.item.backupPublisher) {
    this.item.publisher = this.item.backupPublisher;
    delete this.item.backupPublisher;
  }
};
