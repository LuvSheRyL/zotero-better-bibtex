// Generated by CoffeeScript 1.10.0
var BetterBibTeXParserSupport,
  slice = [].slice;

BetterBibTeXParserSupport = (function() {
  function BetterBibTeXParserSupport(options) {
    this.raw = options.raw;
    this.references = [];
    this.collections = [];
    this.strings = Object.create(null);
    this.comments = [];
    this.errors = [];
  }

  BetterBibTeXParserSupport.prototype.quoteWith = function(state) {
    switch (state) {
      case '"':
        this.braced = false;
        this.quoted = true;
        break;
      case '{}':
        this.braced = true;
        this.quoted = false;
        break;
      default:
        this.braced = false;
        this.quoted = false;
    }
    return true;
  };

  BetterBibTeXParserSupport.prototype.lookahead = function(n) {
    return peg$currPos + " :: " + (input.substr(peg$currPos, n));
  };

  BetterBibTeXParserSupport.prototype.flatten = function(str) {
    var s;
    if (Array.isArray(str)) {
      return ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = str.length; j < len; j++) {
          s = str[j];
          results.push(this.flatten(s));
        }
        return results;
      }).call(this)).join('');
    }
    return '' + str;
  };

  BetterBibTeXParserSupport.prototype.log = function() {
    var m, msg;
    msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    msg = ((function() {
      var j, len, ref1, results;
      results = [];
      for (j = 0, len = msg.length; j < len; j++) {
        m = msg[j];
        results.push((ref1 = typeof m) === 'number' || ref1 === 'string' ? '' + m : JSON.stringify(m));
      }
      return results;
    })()).join(' ');
    msg = "\n\n*** " + msg + " ***\n\n";
    ((typeof Translator !== "undefined" && Translator !== null ? Translator.log : void 0) || console.log)(msg);
    return true;
  };

  BetterBibTeXParserSupport.prototype.filterattachments = function(attachments, key) {
    var attachment, j, len;
    if (key === 'sentelink') {
      for (j = 0, len = attachments.length; j < len; j++) {
        attachment = attachments[j];
        if (attachment.path) {
          attachment.path = attachment.path.replace(/,.*/, '');
        }
      }
    }
    attachments = (function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = attachments.length; k < len1; k++) {
        attachment = attachments[k];
        if (attachment.path && attachment.path !== '') {
          results.push(attachment);
        }
      }
      return results;
    })();
    attachments.sort(function(a, b) {
      if (a.path < b.path) {
        return -1;
      } else if (a.path > b.path) {
        return 1;
      } else {
        return 0;
      }
    });
    return attachments;
  };

  BetterBibTeXParserSupport.prototype.skipEmptyKeys = function(key) {
    return key !== '';
  };

  BetterBibTeXParserSupport.prototype.intersect = function(v) {
    return this.indexOf(v) >= 0;
  };

  BetterBibTeXParserSupport.prototype.unique = function(arr) {
    var j, len, result, v;
    result = [];
    for (j = 0, len = arr.length; j < len; j++) {
      v = arr[j];
      if (result.indexOf(v) < 0) {
        result.push(v);
      }
    }
    return result;
  };

  BetterBibTeXParserSupport.prototype.Creators = new ((function() {
    function _Class() {}

    _Class.prototype.reduce = function(result, fragment) {
      if (result.length === 0) {
        return [fragment];
      }
      if ((result[result.length - 1] instanceof String) || (fragment instanceof String)) {
        return result.concat(fragment);
      }
      result[result.length - 1] += fragment;
      return result;
    };

    _Class.prototype.compact = function(fragments) {
      return fragments.reduce(this.reduce, []);
    };

    _Class.prototype.push = function(groups, fragment, startNewGroup) {
      if (startNewGroup || groups.length === 0) {
        groups.push([]);
      }
      return groups[groups.length - 1].push(fragment);
    };

    _Class.prototype.split = function(fragments, sep, groups) {
      var fragment, group, i, j, k, l, last, len, len1, len2, ref1, splinter;
      if (groups == null) {
        groups = [];
      }
      fragments = this.compact(fragments);
      for (j = 0, len = fragments.length; j < len; j++) {
        fragment = fragments[j];
        if (fragment instanceof String) {
          this.push(groups, fragment);
        } else {
          ref1 = fragment.split(sep);
          for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
            splinter = ref1[i];
            this.push(groups, splinter, i > 0);
          }
        }
      }
      groups = (function() {
        var l, len2, results;
        results = [];
        for (l = 0, len2 = groups.length; l < len2; l++) {
          group = groups[l];
          results.push(this.compact(group));
        }
        return results;
      }).call(this);
      for (l = 0, len2 = groups.length; l < len2; l++) {
        group = groups[l];
        if (group.length === 0) {
          continue;
        }
        if (typeof group[0] === 'string') {
          group[0] = group[0].replace(/^\s+/g, '');
          if (group[0] === '') {
            group.shift();
          }
        }
        if (group.length === 0) {
          continue;
        }
        last = group.length - 1;
        if (typeof group[last] === 'string') {
          group[last] = group[last].replace(/\s+$/g, '');
          if (group[last] === '') {
            group.pop();
          }
        }
      }
      return groups;
    };

    _Class.prototype.join = function(group) {
      return group.join('').trim();
    };

    _Class.prototype.creator = function(name) {
      var firstName, lastName, n;
      name = this.split(name, ",");
      switch (name.length) {
        case 0:
          return null;
        case 1:
          if (name[0].length === 1 && (name[0][0] instanceof String)) {
            return {
              lastName: "" + name[0][0],
              fieldMode: 1
            };
          }
          return this.join(name[0]);
        case 2:
          return {
            lastName: this.join(name[0]),
            firstName: this.join(name[1])
          };
        default:
          firstName = this.join(name.pop());
          lastName = ((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = name.length; j < len; j++) {
              n = name[j];
              results.push(this.join(n));
            }
            return results;
          }).call(this)).join(', ');
          return {
            lastName: lastName,
            firstName: firstName
          };
      }
    };

    _Class.prototype.parse = function(creators) {
      var name;
      return (function() {
        var j, len, ref1, results;
        ref1 = this.split(creators, /\s+and\s+/);
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          name = ref1[j];
          results.push(this.creator(name));
        }
        return results;
      }).call(this);
    };

    return _Class;

  })());

  BetterBibTeXParserSupport.prototype.reference = function(type, citekey, fields) {
    var attachments, field, j, len, note, ref, ref1;
    if (fields.length === 0) {
      return this.errors.push("@" + type + "{" + citekey + ",}");
    } else {
      ref = {
        __type__: type.toLowerCase(),
        __key__: citekey
      };
      for (j = 0, len = fields.length; j < len; j++) {
        field = fields[j];
        if (!(field.value && field.value !== '')) {
          continue;
        }
        switch (field.type) {
          case 'file':
            attachments = (ref1 = ref.file) != null ? ref1 : [];
            ref.file = attachments.concat(field.value);
            break;
          case 'creator':
            if (field.value.length > 0) {
              ref[field.key] = field.value;
            }
            break;
          default:
            if (ref[field.key]) {
              note = ref.__note__ ? ref.__note__ + "<br/>\n" : '';
              ref.__note__ = note + field.key + "=" + field.value;
            } else {
              ref[field.key] = field.value;
            }
        }
      }
      return this.references.push(ref);
    }
  };

  BetterBibTeXParserSupport.prototype.error = function(text) {
    return this.errors.push("@" + (this.flatten(text)));
  };

  BetterBibTeXParserSupport.prototype.comment = function(text) {
    return this.comments.push(this.flatten(text).trim());
  };

  BetterBibTeXParserSupport.prototype.string = function(str) {
    return this.strings[str.verbatimKey] = str.value;
  };

  BetterBibTeXParserSupport.prototype.command = function(command, param) {
    var j, len, variant, variants;
    variants = ["\\" + command + param];
    if (param.length === 1) {
      variants.push("{\\" + command + param + "}");
    }
    if (param.length === 3 && param[0] === '{' && param[2] === '}') {
      variants.push("{\\" + command + param[1] + "}");
    }
    for (j = 0, len = variants.length; j < len; j++) {
      variant = variants[j];
      if (LaTeX.toUnicode[variant]) {
        return LaTeX.toUnicode[variant];
      }
    }
    return param;
  };

  BetterBibTeXParserSupport.prototype.attachment = function(parts) {
    var attachment, ref1, ref2, v;
    parts = (function() {
      var j, len, ref1, results;
      ref1 = parts || [];
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        v = ref1[j];
        results.push(v.trim());
      }
      return results;
    })();
    switch (parts.length) {
      case 0:
        return {};
      case 1:
        attachment = {
          path: parts.shift()
        };
        break;
      default:
        attachment = {
          title: parts.shift()
        };
        attachment.path = (ref1 = parts.shift()) != null ? ref1 : '';
        attachment.mimeType = (ref2 = parts.shift()) != null ? ref2 : '';
    }
    if (!(attachment.title && attachment.title !== '')) {
      attachment.title = 'Attachment';
    }
    if (attachment.mimeType.match(/pdf/i) || attachment.path.match(/\.pdf$/i)) {
      attachment.mimeType = 'application/pdf';
    }
    attachment.path = attachment.path.replace(/\\/g, '/');
    if (attachment.path.match(/^[a-z]:\//i)) {
      attachment.path = "file:///" + attachment.path;
    }
    if (attachment.path.match(/^\/\//)) {
      attachment.path = "file:" + attachment.path;
    }
    return attachment;
  };

  BetterBibTeXParserSupport.prototype.groupsTree = function(id, groups) {
    var collection, collections, group, intersection, j, len, levels;
    levels = Object.create(null);
    collections = [];
    for (j = 0, len = groups.length; j < len; j++) {
      group = groups[j];
      if (!group) {
        continue;
      }
      collection = Object.create(null);
      collection.name = group.data.shift();
      intersection = group.data.shift();
      collection.items = group.data.filter(bibtex.skipEmptyKeys);
      collection.collections = [];
      levels[group.level] = collection;
      if (group.level === 1) {
        collections.push(collection);
      } else {
        levels[group.level - 1].collections.push(collection);
        switch (intersection) {
          case "1":
            collection.items = collection.items.filter(bibtex.intersect, levels[group.level - 1].items);
            break;
          case "2":
            collection.items = bibtex.unique(levels[group.level - 1].items.concat(collection.items));
        }
      }
    }
    return this.collections = this.collections.concat(collections);
  };

  return BetterBibTeXParserSupport;

})();
