// Generated by CoffeeScript 1.10.0
var detectImport, doExport, doImport, scrub,
  hasProp = {}.hasOwnProperty;

scrub = function(item) {
  var attachment, attr, citekeys, creator, j, len, note, ref, tag, val;
  delete item.__citekey__;
  delete item.libraryID;
  delete item.key;
  delete item.uniqueFields;
  delete item.dateAdded;
  delete item.dateModified;
  delete item.uri;
  delete item.multi;
  delete item.attachmentIDs;
  delete item.collections;
  ref = item.creators || [];
  for (j = 0, len = ref.length; j < len; j++) {
    creator = ref[j];
    delete creator.creatorID;
    delete creator.multi;
  }
  item.attachments = (function() {
    var k, len1, ref1, results;
    ref1 = item.attachments || [];
    results = [];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      attachment = ref1[k];
      results.push({
        path: attachment.localPath,
        title: attachment.title,
        mimeType: attachment.mimeType,
        url: attachment.url
      });
    }
    return results;
  })();
  item.notes = (function() {
    var k, len1, ref1, results;
    ref1 = item.notes || [];
    results = [];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      note = ref1[k];
      results.push(note.note.trim());
    }
    return results;
  })();
  item.tags = (function() {
    var k, len1, ref1, results;
    ref1 = item.tags || [];
    results = [];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      tag = ref1[k];
      results.push(tag.tag);
    }
    return results;
  })();
  item.tags.sort();
  for (attr in item) {
    if (!hasProp.call(item, attr)) continue;
    val = item[attr];
    if (typeof val === 'number') {
      continue;
    }
    if (Array.isArray(val) && val.length !== 0) {
      continue;
    }
    switch (typeof val) {
      case 'string':
        if (val.trim() === '') {
          delete item[attr];
        }
        break;
      case 'undefined':
        delete item[attr];
    }
  }
  citekeys = Zotero.BetterBibTeX.keymanager.alternates(item);
  switch (false) {
    case !(!citekeys || citekeys.length === 0):
      break;
    case citekeys.length !== 1:
      item.__citekey__ = citekeys[0];
      break;
    default:
      item.__citekeys__ = citekeys;
  }
  return item;
};

detectImport = function() {
  var data, e, error, json, match, ref, str;
  json = '';
  while ((str = Zotero.read(0x100000)) !== false) {
    json += str;
  }
  try {
    data = JSON.parse(json);
  } catch (error) {
    e = error;
    Translator.log('BetterBibTeX JSON.detect failed:', e);
    return false;
  }
  match = (data != null ? (ref = data.config) != null ? ref.id : void 0 : void 0) === Translator.header.translatorID && data.items;
  Translator.log('BetterBibTeX JSON.detect:', match);
  return match;
};

doImport = function() {
  var att, data, i, item, j, json, k, len, len1, prop, ref, ref1, results, str, value;
  json = '';
  while ((str = Zotero.read(0x100000)) !== false) {
    json += str;
  }
  data = JSON.parse(json);
  ref = data.items;
  results = [];
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    item = new Zotero.Item();
    for (prop in i) {
      if (!hasProp.call(i, prop)) continue;
      value = i[prop];
      item[prop] = value;
    }
    ref1 = item.attachments || [];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      att = ref1[k];
      if (att.url) {
        delete att.path;
      }
    }
    results.push(item.complete());
  }
  return results;
};

doExport = function() {
  var data, item;
  Translator.initialize();
  data = {
    config: {
      id: Translator.header.translatorID,
      label: Translator.header.label,
      release: Translator.release,
      preferences: Translator.preferences,
      options: Translator.options
    },
    collections: Translator.collections,
    items: [],
    cache: {}
  };
  while (item = Zotero.nextItem()) {
    data.items.push(scrub(item));
  }
  if (Zotero.getHiddenPref('better-bibtex.debug')) {
    data.keymanager = Zotero.BetterBibTeX.keymanager.cache();
    data.cache.items = Zotero.BetterBibTeX.cache.dump((function() {
      var j, len, ref, results;
      ref = data.items;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        results.push(item.itemID);
      }
      return results;
    })());
  }
  Zotero.write(JSON.stringify(data, null, '  '));
};
