// Generated by CoffeeScript 1.10.0
var hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Zotero.BetterBibTeX.cache = new ((function() {
  function _Class() {
    this.db = Zotero.BetterBibTeX.DB;
    this.stats = {
      hit: 0,
      miss: 0,
      clear: 0
    };
  }

  _Class.prototype.integer = function(v) {
    var _v;
    if (typeof v === 'number') {
      return v;
    }
    _v = parseInt(v);
    if (isNaN(_v)) {
      throw new Error(v + " is not an integer-string");
    }
    return _v;
  };

  _Class.prototype.verify = function(entry) {
    var key, value, verify;
    if (!(Zotero.BetterBibTeX.pref.get('debug') || Zotero.BetterBibTeX.testing)) {
      return entry;
    }
    verify = {
      itemID: 1,
      exportCharset: 'x',
      exportNotes: true,
      translatorID: 'x',
      useJournalAbbreviation: true
    };
    for (key in entry) {
      if (!hasProp.call(entry, key)) continue;
      value = entry[key];
      switch (false) {
        case key !== '$loki' && key !== 'meta':
          break;
        case verify[key] !== void 0:
          throw new Error("Unexpected field " + key + " in " + (typeof entry) + " " + (JSON.stringify(entry)));
          break;
        case verify[key] !== null:
          delete verify[key];
          break;
        case !(typeof verify[key] === 'string' && typeof value === 'string' && value.trim() !== ''):
          delete verify[key];
          break;
        case !(typeof verify[key] === 'number' && typeof value === 'number'):
          delete verify[key];
          break;
        case !(typeof verify[key] === 'boolean' && typeof value === 'boolean'):
          delete verify[key];
          break;
        default:
          throw new Error("field " + key + " of " + (typeof entry) + " " + (JSON.stringify(entry)) + " is unexpected " + (typeof value) + " " + value);
      }
    }
    verify = Object.keys(verify);
    if (verify.length === 0) {
      return entry;
    }
    throw new Error("missing fields " + verify + " in " + (typeof entry) + " " + (JSON.stringify(entry)));
  };

  _Class.prototype.remove = function(what) {
    this.stats.clear++;
    if (what.itemID !== void 0) {
      what.itemID = this.integer(what.itemID);
    }
    return this.db.cache.removeWhere(what);
  };

  _Class.prototype.reset = function(reason) {
    Zotero.BetterBibTeX.debug('cache.reset:', new Error(reason));
    this.db.cache.removeDataOnly();
    return this.stats = {
      hit: 0,
      miss: 0,
      clear: 0
    };
  };

  _Class.prototype.record = function(itemID, context) {
    return this.verify({
      itemID: this.integer(itemID),
      exportCharset: (context.exportCharset || 'UTF-8').toUpperCase(),
      exportNotes: !!context.exportNotes,
      translatorID: context.translatorID,
      useJournalAbbreviation: !!context.useJournalAbbreviation
    });
  };

  _Class.prototype.clone = function(obj) {
    var clone;
    clone = JSON.parse(JSON.stringify(obj));
    delete clone.meta;
    delete clone['$loki'];
    return clone;
  };

  _Class.prototype.dump = function(itemIDs) {
    var cache, cached, id;
    itemIDs = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = itemIDs.length; i < len; i++) {
        id = itemIDs[i];
        results.push(parseInt(id));
      }
      return results;
    })();
    cache = (function() {
      var i, len, ref, results;
      ref = this.db.cache.where(function(o) {
        var ref;
        return ref = o.itemID, indexOf.call(itemIDs, ref) >= 0;
      });
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        cached = ref[i];
        results.push(this.clone(cached));
      }
      return results;
    }).call(this);
    return cache;
  };

  _Class.prototype.fetch = function(itemID, context) {
    var cached;
    Zotero.BetterBibTeX.debug('cache.fetch:', {
      itemID: itemID,
      context: context
    });
    if (context.exportFileData) {
      return;
    }
    cached = this.db.cache.findOne({
      '$and': [
        {
          itemID: this.integer(itemID)
        }, {
          exportCharset: context.exportCharset
        }, {
          exportNotes: context.exportNotes
        }, {
          translatorID: context.translatorID
        }, {
          useJournalAbbreviation: context.useJournalAbbreviation
        }
      ]
    });
    if (cached) {
      this.db.cacheAccess[cached.$loki] = Date.now();
      this.stats.hit++;
      Zotero.BetterBibTeX.debug('cache.fetch: hit');
    } else {
      this.stats.miss++;
      Zotero.BetterBibTeX.debug('cache.fetch: miss');
    }
    return cached;
  };

  _Class.prototype.store = function(itemID, context, citekey, bibtex) {
    var cached, record;
    if (context.exportFileData) {
      return;
    }
    record = this.record(itemID, context);
    cached = this.db.cache.findObject(record);
    if (cached) {
      cached.citekey = citekey;
      cached.bibtex = bibtex;
      cached.accessed = Date.now();
      return this.db.cache.update(cached);
    } else {
      record.citekey = citekey;
      record.bibtex = bibtex;
      record.accessed = Date.now();
      return this.db.cache.insert(record);
    }
  };

  return _Class;

})());
