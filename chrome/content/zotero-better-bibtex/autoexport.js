// Generated by CoffeeScript 1.10.0
var hasProp = {}.hasOwnProperty;

Zotero.BetterBibTeX.auto = new ((function() {
  function _Class() {
    this.db = Zotero.BetterBibTeX.DB;
    this.search = {};
    this.idle = false;
  }

  _Class.prototype.mark = function(ae, status) {
    Zotero.BetterBibTeX.debug('mark:', {
      ae: ae,
      status: status
    });
    ae.updated = (new Date()).toLocaleString();
    ae.status = status;
    return this.db.autoexport.update(ae);
  };

  _Class.prototype.markSearch = function(id) {
    var ae, itemID, items, search;
    search = Zotero.Searches.get(id);
    if (!search) {
      return false;
    }
    items = (function() {
      var i, len, ref, results;
      ref = search.search();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        itemID = ref[i];
        results.push(parseInt(itemID));
      }
      return results;
    })();
    items.sort();
    if (items === this.search[parseInt(search.id)]) {
      return;
    }
    this.search[parseInt(search.id)] = items;
    ae = this.db.autoexport.findObject({
      collection: "search:" + id
    });
    if (ae) {
      return this.mark(ae, 'pending');
    }
  };

  _Class.prototype.refresh = function() {
    var enumerator, win, wm;
    wm = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator);
    enumerator = wm.getEnumerator('zotero:pref');
    if (enumerator.hasMoreElements()) {
      win = enumerator.getNext();
      return win.BetterBibTeXAutoExportPref.refresh(true);
    }
  };

  _Class.prototype.add = function(collection, path, context) {
    Zotero.BetterBibTeX.debug("auto-export set up for " + collection + " to " + path);
    this.db.autoexport.removeWhere({
      path: path
    });
    this.db.autoexport.insert({
      collection: collection,
      path: path,
      translatorID: context.translatorID,
      exportCharset: (context.exportCharset || 'UTF-8').toUpperCase(),
      exportNotes: !!context.exportNotes,
      useJournalAbbreviation: !!context.useJournalAbbreviation,
      exportedRecursively: this.recursive(),
      status: 'done'
    });
    return this.refresh();
  };

  _Class.prototype.recursive = function() {
    try {
      return Zotero.Prefs.get('recursiveCollections');
    } catch (undefined) {}
    return false;
  };

  _Class.prototype.clear = function() {
    this.db.autoexport.removeDataOnly();
    return this.refresh();
  };

  _Class.prototype.reset = function() {
    var ae, i, len, ref;
    ref = this.db.autoexport.chain().data();
    for (i = 0, len = ref.length; i < len; i++) {
      ae = ref[i];
      this.mark(ae, 'pending');
    }
    return this.refresh();
  };

  _Class.prototype.prepare = function(ae) {
    var items, k, m, msg, path, translation, v;
    Zotero.BetterBibTeX.debug('auto.prepare: candidate', ae);
    path = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
    path.initWithPath(ae.path);
    if (path.exists() && !(path.isFile() && path.isWritable())) {
      msg = "auto.prepare: candidate path '" + ae.path + "' exists but is not writable";
      Zotero.BetterBibTeX.debug(msg);
      this.mark(ae, 'error');
      throw new Error(msg);
    }
    if (!(path.parent.exists() && path.parent.isDirectory() && path.parent.isWritable())) {
      msg = "auto.prepare: parent of candidate path '" + ae.path + "' exists but is not writable";
      Zotero.BetterBibTeX.debug(msg);
      this.mark(ae, 'error');
      throw new Error(msg);
    }
    switch (false) {
      case ae.collection !== 'library':
        items = {
          library: null
        };
        break;
      case !(m = /^search:([0-9]+)$/.exec(ae.collection)):
        items = {
          items: this.search[parseInt(m[1])] || []
        };
        if (items.items.length === 0) {
          Zotero.BetterBibTeX.debug('auto.process: empty search');
          return null;
        } else {
          items.items = Zotero.Items.get(items.items);
        }
        break;
      case !(m = /^library:([0-9]+)$/.exec(ae.collection)):
        items = {
          library: parseInt(m[1])
        };
        break;
      case !(m = /^collection:([0-9]+)$/.exec(ae.collection)):
        items = {
          collection: parseInt(m[1])
        };
        break;
      default:
        Zotero.BetterBibTeX.debug('auto.process: unexpected collection id ', ae.collection);
        return null;
    }
    if (items.items && items.items.length === 0) {
      Zotero.BetterBibTeX.debug('auto.prepare: candidate ', ae.path, ' has no items');
      return null;
    }
    translation = new Zotero.Translate.Export();
    for (k in items) {
      if (!hasProp.call(items, k)) continue;
      v = items[k];
      switch (k) {
        case 'items':
          Zotero.BetterBibTeX.debug('preparing auto-export from', items.length, 'items');
          translation.setItems(items.items);
          break;
        case 'collection':
          Zotero.BetterBibTeX.debug('preparing auto-export from collection', items.collection);
          translation.setCollection(Zotero.Collections.get(items.collection));
          break;
        case 'library':
          Zotero.BetterBibTeX.debug('preparing auto-export from library', items.library);
          translation.setLibraryID(items.library);
      }
    }
    translation.setLocation(path);
    translation.setTranslator(ae.translatorID);
    translation.setDisplayOptions({
      exportCharset: ae.exportCharset,
      exportNotes: ae.exportNotes,
      useJournalAbbreviation: ae.useJournalAbbreviation
    });
    return translation;
  };

  _Class.prototype.process = function(reason) {
    var ae, err, error, i, len, ref, skip, translation;
    Zotero.BetterBibTeX.debug("auto.process: started (" + reason + "), idle: " + this.idle);
    if (this.running) {
      Zotero.BetterBibTeX.debug('auto.process: export already running');
      return;
    }
    switch (Zotero.BetterBibTeX.pref.get('autoExport')) {
      case 'off':
        Zotero.BetterBibTeX.debug('auto.process: off');
        return;
      case 'idle':
        if (!this.idle) {
          Zotero.BetterBibTeX.debug('auto.process: not idle');
          return;
        }
    }
    skip = {
      error: [],
      done: []
    };
    translation = null;
    ref = this.db.autoexport.findObjects({
      status: 'pending'
    });
    for (i = 0, len = ref.length; i < len; i++) {
      ae = ref[i];
      try {
        translation = this.prepare(ae);
      } catch (error) {
        err = error;
        Zotero.BetterBibTeX.debug('auto.process:', err);
        continue;
      }
      if (!translation) {
        this.mark(ae, 'done');
      } else {
        break;
      }
    }
    if (translation) {
      this.running = '' + ae.$loki;
    } else {
      Zotero.BetterBibTeX.debug('auto.process: no pending jobs');
      return;
    }
    Zotero.BetterBibTeX.debug('auto.process: starting', ae);
    this.refresh();
    translation.setHandler('done', (function(_this) {
      return function(obj, worked) {
        var status;
        status = (worked ? 'done' : 'error');
        Zotero.BetterBibTeX.debug("auto.process: finished " + Zotero.BetterBibTeX.auto.running + ": " + status);
        _this.mark(ae, status);
        Zotero.BetterBibTeX.auto.running = null;
        Zotero.BetterBibTeX.auto.refresh();
        return Zotero.BetterBibTeX.auto.process(reason);
      };
    })(this));
    return translation.translate();
  };

  return _Class;

})());
