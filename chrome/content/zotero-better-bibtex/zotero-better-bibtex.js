// Generated by CoffeeScript 1.10.0
var slice = [].slice,
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Components.utils["import"]('resource://gre/modules/Services.jsm');

Components.utils["import"]('resource://gre/modules/AddonManager.jsm');

Components.utils["import"]('resource://zotero/config.js');

Zotero.BetterBibTeX = {
  serializer: Components.classes['@mozilla.org/xmlextras/xmlserializer;1'].createInstance(Components.interfaces.nsIDOMSerializer),
  document: Components.classes['@mozilla.org/xul/xul-document;1'].getService(Components.interfaces.nsIDOMDocument),
  Cache: new loki('betterbibtex.db', {
    env: 'BROWSER'
  })
};

Components.utils["import"]('resource://zotero-better-bibtex/citeproc.js', Zotero.BetterBibTeX);

Zotero.BetterBibTeX.titleCase = {
  state: {
    opt: {
      lang: 'en'
    },
    locale: {
      en: {
        opts: {
          'skip-words': Zotero.BetterBibTeX.CSL.SKIP_WORDS,
          'leading-noise-words': 'a,an,the'
        }
      }
    }
  }
};

Zotero.BetterBibTeX.titleCase.state.locale.en.opts['skip-words-regexp'] = new RegExp('(?:(?:[?!:]*\\s+|-|^)(?:' + Zotero.BetterBibTeX.titleCase.state.locale.en.opts['skip-words'].slice().join('|') + ')(?=[!?:]*\\s+|-|$))', 'g');

Zotero.BetterBibTeX.HTMLParser = new ((function() {
  function _Class() {}

  _Class.prototype.DOMParser = Components.classes["@mozilla.org/xmlextras/domparser;1"].createInstance(Components.interfaces.nsIDOMParser);

  _Class.prototype.ELEMENT_NODE = 1;

  _Class.prototype.TEXT_NODE = 3;

  _Class.prototype.CDATA_SECTION_NODE = 4;

  _Class.prototype.PROCESSING_INSTRUCTION_NODE = 7;

  _Class.prototype.COMMENT_NODE = 8;

  _Class.prototype.DOCUMENT_NODE = 9;

  _Class.prototype.DOCUMENT_TYPE_NODE = 10;

  _Class.prototype.DOCUMENT_FRAGMENT_NODE = 11;

  _Class.prototype.text = function(html) {
    var doc, txt;
    doc = this.DOMParser.parseFromString("<span>" + html + "</span>", 'text/html');
    if (doc.nodeType === this.DOCUMENT_NODE) {
      doc = doc.documentElement;
    }
    txt = doc.textContent;
    Zotero.BetterBibTeX.debug('html2text:', {
      html: html,
      txt: txt
    });
    return txt;
  };

  _Class.prototype.parse = function(html) {
    return this.walk(this.DOMParser.parseFromString("<span>" + html + "</span>", 'text/html'));
  };

  _Class.prototype.walk = function(node, json) {
    var attr, child, cls, j, l, len, len1, n, ref, ref1, ref2, ref3, tag;
    tag = {
      name: node.nodeName.toLowerCase(),
      attrs: {},
      "class": {},
      children: []
    };
    if ((ref = node.nodeType) === this.TEXT_NODE || ref === this.CDATA_SECTION_NODE) {
      tag.text = node.textContent;
    } else {
      if (tag.name === 'script') {
        tag.text = node.text;
      }
      if (node.nodeType === this.ELEMENT_NODE && node.hasAttributes()) {
        ref1 = node.attributes;
        for (j = 0, len = ref1.length; j < len; j++) {
          attr = ref1[j];
          tag.attrs[attr.name] = attr.value;
        }
        if (tag.attrs["class"]) {
          ref2 = tag.attrs["class"].split(/\s+/);
          for (l = 0, len1 = ref2.length; l < len1; l++) {
            cls = ref2[l];
            if (!cls) {
              continue;
            }
            tag["class"][cls] = true;
          }
        }
      }
      if (node.childNodes) {
        for (child = n = 0, ref3 = node.childNodes.length; 0 <= ref3 ? n < ref3 : n > ref3; child = 0 <= ref3 ? ++n : --n) {
          this.walk(node.childNodes.item(child), tag);
        }
      }
    }
    if (!json) {
      return tag;
    }
    json.children.push(tag);
    return json;
  };

  return _Class;

})());

Zotero.BetterBibTeX.DateParser = (function() {
  DateParser.prototype.parseDateToObject = function(date, options) {
    return (new Zotero.BetterBibTeX.DateParser(date, options)).date;
  };

  DateParser.prototype.parseDateToArray = function(date, options) {
    return (new Zotero.BetterBibTeX.DateParser(date, options)).array();
  };

  DateParser.prototype.toArray = function(suffix) {
    var arr, d, date, j, len, ref;
    if (suffix == null) {
      suffix = '';
    }
    date = {};
    ref = ['year', 'month', 'day', 'empty'];
    for (j = 0, len = ref.length; j < len; j++) {
      d = ref[j];
      date[d] = this.date["" + d + suffix];
    }
    if (date.empty) {
      return [0];
    }
    if (!date.year) {
      return null;
    }
    arr = [date.year];
    if (date.month) {
      arr.push(date.month);
      if (date.day) {
        arr.push(date.day);
      }
    }
    return arr;
  };

  DateParser.prototype.array = function() {
    var array, date1, date2;
    date1 = this.toArray();
    if (!date1) {
      return {
        literal: this.source
      };
    }
    date2 = this.toArray('_end');
    array = {
      'date-parts': (date2 ? [date1, date2] : [date1])
    };
    if (this.date.circa || this.date.circa_end) {
      array.circa = true;
    }
    return array;
  };

  function DateParser(source, options) {
    var fallback, found, k, locale, ref, v;
    this.source = source;
    if (options == null) {
      options = {};
    }
    if (this.source) {
      this.source = this.source.trim();
    }
    if (this.zoteroLocale == null) {
      this.zoteroLocale = Zotero.locale.toLowerCase();
    }
    if (!this.source) {
      return;
    }
    if (options.verbatimDetection && this.source.indexOf('[') >= 0) {
      this.date = {
        literal: this.source
      };
      return;
    }
    if (options.locale) {
      locale = options.locale.toLowerCase();
      this.dateorder = Zotero.BetterBibTeX.Locales.dateorder[locale];
      if (this.dateorder) {
        found = locale;
      } else {
        ref = Zotero.BetterBibTeX.Locales.dateorder;
        for (k in ref) {
          v = ref[k];
          if (k === locale || k.slice(0, locale.length) === locale) {
            found = k;
            this.dateorder = Zotero.BetterBibTeX.Locales.dateorder[options.locale] = v;
            break;
          }
        }
      }
    }
    if (!this.dateorder) {
      fallback = Zotero.BetterBibTeX.pref.get('defaultDateParserLocale');
      this.dateorder = Zotero.BetterBibTeX.Locales.dateorder[fallback];
      if (!this.dateorder) {
        this.dateorder = Zotero.BetterBibTeX.Locales.dateorder[fallback] = Zotero.BetterBibTeX.Locales.dateorder[fallback.trim().toLowerCase()];
      }
    }
    this.dateorder || (this.dateorder = Zotero.BetterBibTeX.Locales.dateorder[this.zoteroLocale]);
    this.date = this.parse();
  }

  DateParser.prototype.swapMonth = function(date, dateorder) {
    var ref;
    if (!(date.day && date.month)) {
      return;
    }
    switch (false) {
      case !(this.dateorder && this.dateorder === dateorder && date.day <= 12):
        break;
      case !(date.month > 12):
        break;
      default:
        return;
    }
    return ref = [date.day, date.month], date.month = ref[0], date.day = ref[1], ref;
  };

  DateParser.prototype.cruft = new Zotero.Utilities.XRegExp("[^\\p{Letter}\\p{Number}]+", 'g');

  DateParser.prototype.parsedate = function(date) {
    var fields, k, m, parsed, shape, v;
    date = date.trim();
    if (date === '') {
      return {
        empty: true
      };
    }
    date = date.replace(/^([0-9]+)\.\s+([a-z])/i, '$1 $2');
    if (m = date.match(/^(-?[0-9]{3,4})(\?)?(~)?$/)) {
      return {
        year: this.year(m[1]),
        uncertain: (m[2] === '?' ? true : void 0),
        circa: (m[3] === '?' ? true : void 0)
      };
    }
    if (m = date.match(/^(([0-9]{1,2})[-\.\s\/])?([0-9]{1,2})[-\.\s\/]([0-9]{3,4})(\?)?(~)?$/)) {
      parsed = {
        year: parseInt(m[4]),
        month: parseInt(m[3]),
        day: parseInt(m[1]) || void 0,
        uncertain: (m[5] === '?' ? true : void 0),
        circa: (m[6] === '~' ? true : void 0)
      };
      this.swapMonth(parsed, 'mdy');
      return parsed;
    }
    if (m = date.match(/^(-?[0-9]{3,4})[-\.\s\/]([0-9]{1,2})([-\.\s\/]([0-9]{1,2}))?(\?)?(~)?$/)) {
      parsed = {
        year: this.year(m[1]),
        month: parseInt(m[2]),
        day: parseInt(m[4]) || void 0,
        uncertain: (m[5] === '?' ? true : void 0),
        circa: (m[6] === '~' ? true : void 0)
      };
      this.swapMonth(parsed);
      return parsed;
    }
    parsed = Zotero.BetterBibTeX.CSL.DateParser.parseDateToObject(date);
    for (k in parsed) {
      v = parsed[k];
      switch (false) {
        case v !== 'NaN':
          parsed[k] = void 0;
          break;
        case !(typeof v === 'string' && v.match(/^-?[0-9]+$/)):
          parsed[k] = parseInt(v);
      }
    }
    if (parsed.literal) {
      return null;
    }
    if (parsed.month && parsed.month > 12) {
      return null;
    }
    shape = date;
    if (shape[0] === '-') {
      shape = shape.slice(1);
    }
    shape = Zotero.Utilities.XRegExp.replace(shape.trim(), this.cruft, ' ', 'all');
    shape = shape.split(' ');
    fields = (parsed.year ? 1 : 0) + (parsed.month ? 1 : 0) + (parsed.day ? 1 : 0);
    if (fields === 3 || shape.length === fields) {
      return parsed;
    }
    return null;
  };

  DateParser.prototype.parserange = function(separators) {
    var j, len, range, sep;
    for (j = 0, len = separators.length; j < len; j++) {
      sep = separators[j];
      if (this.source === sep) {
        continue;
      }
      if (sep === '-' && this.source.match(/^-[0-9]{3,4}$/)) {
        continue;
      }
      range = this.source.split(sep);
      if (range.length !== 2) {
        continue;
      }
      range = [this.parsedate(range[0]), this.parsedate(range[1])];
      if (!(range[0] && range[1])) {
        continue;
      }
      return {
        empty: range[0].empty,
        year: range[0].year,
        month: range[0].month,
        day: range[0].day,
        circa: range[0].circa,
        empty_end: range[1].empty,
        year_end: range[1].year,
        month_end: range[1].month,
        day_end: range[1].day,
        circa_end: range[1].circa
      };
    }
    return null;
  };

  DateParser.prototype.year = function(y) {
    y = parseInt(y);
    if (y <= 0) {
      y -= 1;
    }
    return y;
  };

  DateParser.prototype.parse = function() {
    var candidate, ref;
    if (!this.source || ((ref = this.source) === '--' || ref === '/' || ref === '_')) {
      return {};
    }
    candidate = this.parserange(['--', '_', '/', '-']);
    candidate || (candidate = this.parsedate(this.source));
    candidate || (candidate = {
      literal: this.source
    });
    return candidate;
  };

  return DateParser;

})();

Zotero.BetterBibTeX.error = function() {
  var msg;
  msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return this._log.apply(this, [0].concat(msg));
};

Zotero.BetterBibTeX.warn = function() {
  var msg;
  msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return this._log.apply(this, [1].concat(msg));
};

Zotero.BetterBibTeX.debug_off = function() {};

Zotero.BetterBibTeX.debug = Zotero.BetterBibTeX.debug_on = function() {
  var msg;
  msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return this._log.apply(this, [5].concat(msg));
};

Zotero.BetterBibTeX.log_off = function() {};

Zotero.BetterBibTeX.log = Zotero.BetterBibTeX.log_on = function() {
  var msg;
  msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return this._log.apply(this, [3].concat(msg));
};

Zotero.BetterBibTeX.addCacheHistory = function() {
  var base;
  (base = Zotero.BetterBibTeX).cacheHistory || (base.cacheHistory = []);
  return Zotero.BetterBibTeX.cacheHistory.push({
    timestamp: new Date(),
    serialized: {
      hit: Zotero.BetterBibTeX.serialized.stats.hit,
      miss: Zotero.BetterBibTeX.serialized.stats.miss,
      clear: Zotero.BetterBibTeX.serialized.stats.clear
    },
    cache: {
      hit: Zotero.BetterBibTeX.cache.stats.hit,
      miss: Zotero.BetterBibTeX.cache.stats.miss,
      clear: Zotero.BetterBibTeX.cache.stats.clear
    }
  });
};

Zotero.BetterBibTeX.debugMode = function() {
  var error1;
  if (this.pref.get('debug')) {
    Zotero.Debug.setStore(true);
    Zotero.Prefs.set('debug.store', true);
    this.debug = this.debug_on;
    this.log = this.log_on;
    this.flash('Debug mode active', 'Debug mode is active. This will affect performance.');
    if (Zotero.BetterBibTeX.debugInterval) {
      clearInterval(Zotero.BetterBibTeX.debugInterval);
    }
    try {
      return Zotero.BetterBibTeX.debugInterval = setInterval(function() {
        return Zotero.BetterBibTeX.addCacheHistory();
      }, 10000);
    } catch (error1) {
      return delete Zotero.BetterBibTeX.debugInterval;
    }
  } else {
    if (Zotero.BetterBibTeX.debugInterval) {
      clearInterval(Zotero.BetterBibTeX.debugInterval);
    }
    delete Zotero.BetterBibTeX.debugInterval;
    delete Zotero.BetterBibTeX.cacheHistory;
    this.debug = this.debug_off;
    return this.log = this.log_off;
  }
};

Zotero.BetterBibTeX.stringify = function(obj, replacer, spaces, cycleReplacer) {
  var hybrid, j, key, keys, len, o, str;
  str = JSON.stringify(obj, this.stringifier(replacer, cycleReplacer), spaces);
  if (Array.isArray(obj)) {
    hybrid = false;
    keys = Object.keys(obj);
    if (keys.length > 0) {
      o = {};
      for (j = 0, len = keys.length; j < len; j++) {
        key = keys[j];
        if (key.match(/^\d+$/)) {
          continue;
        }
        o[key] = obj[key];
        hybrid = true;
      }
      if (hybrid) {
        str += '+' + this.stringify(o);
      }
    }
  }
  return str;
};

Zotero.BetterBibTeX.stringifier = function(replacer, cycleReplacer) {
  var keys, stack;
  stack = [];
  keys = [];
  if (cycleReplacer === null) {
    cycleReplacer = function(key, value) {
      if (stack[0] === value) {
        return '[Circular ~]';
      }
      return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    };
  }
  return function(key, value) {
    var thisPos;
    if (stack.length > 0) {
      thisPos = stack.indexOf(this);
      if (~thisPos) {
        stack.splice(thisPos + 1);
      } else {
        stack.push(this);
      }
      if (~thisPos) {
        keys.splice(thisPos, Infinity, key);
      } else {
        keys.push(key);
      }
      if (~stack.indexOf(value)) {
        value = cycleReplacer.call(this, key, value);
      }
    } else {
      stack.push(value);
    }
    if (replacer === null || replacer === void 0) {
      return value;
    }
    return replacer.call(this, key, value);
  };
};

Zotero.BetterBibTeX._log = function() {
  var j, len, level, m, msg, ref, s, str;
  level = arguments[0], msg = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  str = [];
  for (j = 0, len = msg.length; j < len; j++) {
    m = msg[j];
    switch (false) {
      case (ref = typeof m) !== 'boolean' && ref !== 'string' && ref !== 'number':
        str.push('' + m);
        break;
      case !(m instanceof Error):
        str.push("<Exception: " + m.msg + (m.stack ? '\n' + m.stack : '') + ">");
        break;
      default:
        str.push(Zotero.BetterBibTeX.stringify(m));
    }
  }
  str = (function() {
    var l, len1, results;
    results = [];
    for (l = 0, len1 = str.length; l < len1; l++) {
      s = str[l];
      if (s !== '') {
        results.push(s);
      }
    }
    return results;
  })();
  str = str.join(' ');
  if (level === 0) {
    return Zotero.logError('[better' + '-' + 'bibtex] ' + str);
  } else {
    return Zotero.debug('[better' + '-' + 'bibtex] ' + str, level);
  }
};

Zotero.BetterBibTeX.extensionConflicts = function() {
  var ref, ref1;
  AddonManager.getAddonByID('zoteromaps@zotero.org', function(extension) {
    if (!extension) {
      return;
    }
    if (Services.vc.compare(extension.version, '1.0.10.1') > 0) {
      return;
    }
    return Zotero.BetterBibTeX.disable('Better BibTeX has been disabled because it has detected conflicting extension "zotero-maps" 1.0.10 or\nearlier. Unfortunately this plugin appears to be abandoned, and their issue tracker at\n\nhttps://github.com/zotero/zotero-maps\n\nis not enabled.');
  });
  AddonManager.getAddonByID('zutilo@www.wesailatdawn.com', function(extension) {
    if (!extension) {
      return;
    }
    if (Services.vc.compare(extension.version, '1.2.10.1') > 0) {
      return;
    }
    return Zotero.BetterBibTeX.disable('Better BibTeX has been disabled because it has detected conflicting extension "zutilo" 1.2.10.1 or\nearlier. If have proposed a fix at\n\nhttps://github.com/willsALMANJ/Zutilo/issues/42\n\nOnce that has been implemented, Better BibTeX will start up as usual. In the meantime, beta7 from\n\nhttps://addons.mozilla.org/en-US/firefox/addon/zutilo-utility-for-zotero/versions/\n\nshould work; alternately, you can uninstall Zutilo.');
  });
  AddonManager.getAddonByID('{359f0058-a6ca-443e-8dd8-09868141bebc}', function(extension) {
    if (!extension) {
      return;
    }
    if (Services.vc.compare(extension.version, '1.2.3') > 0) {
      return;
    }
    return Zotero.BetterBibTeX.disable('Better BibTeX has been disabled because it has detected conflicting extension "recoll-firefox" 1.2.3 or\nearlier. If have proposed a fix for recall-firefox at\n\nhttps://sourceforge.net/p/recollfirefox/discussion/general/thread/a31d3c89/\n\nOnce that has been implemented, Better BibTeX will start up as usual.  Alternately, you can uninstall Recoll Firefox.\n\nIn the meantime, unfortunately, Better BibTeX and recoll-firefox cannot co-exist, and the previous workaround\nBetter BibTeX had in place conflicts with a Mozilla policy all Fireox extensions must soon comply with.');
  });
  if ((ref = ZOTERO_CONFIG.VERSION) != null ? ref.match(/\.SOURCE$/) : void 0) {
    this.flash(("You are on a custom Zotero build (" + ZOTERO_CONFIG.VERSION + "). ") + 'Feel free to submit error reports for Better BibTeX when things go wrong, I will do my best to address them, but the target will always be the latest officially released version of Zotero');
  }
  if (Services.vc.compare(((ref1 = ZOTERO_CONFIG.VERSION) != null ? ref1.replace(/\.SOURCE$/, '') : void 0) || '0.0.0', '4.0.28') < 0) {
    return this.disable("Better BibTeX has been disabled because it found Zotero " + ZOTERO_CONFIG.VERSION + ", but requires 4.0.28 or later.");
  }
};

Zotero.BetterBibTeX.disable = function(message) {
  this.removeTranslators();
  this.disabled = message;
  return this.flash('Better BibTeX has been disabled', message);
};

Zotero.BetterBibTeX.flash = function(title, body) {
  var err, error1, pw;
  try {
    Zotero.BetterBibTeX.debug('flash:', title);
    pw = new Zotero.ProgressWindow();
    pw.changeHeadline(title);
    body || (body = title);
    if (Array.isArray(body)) {
      body = body.join("\n");
    }
    pw.addDescription(body);
    pw.show();
    return pw.startCloseTimer(8000);
  } catch (error1) {
    err = error1;
    return Zotero.BetterBibTeX.error('@flash failed:', {
      title: title,
      body: body
    }, err);
  }
};

Zotero.BetterBibTeX.reportErrors = function(includeReferences) {
  var collectionsView, data, itemGroup, pane, params, ref, ww;
  data = {};
  pane = Zotero.getActiveZoteroPane();
  switch (includeReferences) {
    case 'collection':
      collectionsView = pane != null ? pane.collectionsView : void 0;
      itemGroup = collectionsView != null ? collectionsView._getItemAtRow((ref = collectionsView.selection) != null ? ref.currentIndex : void 0) : void 0;
      switch (itemGroup != null ? itemGroup.type : void 0) {
        case 'collection':
          data = {
            data: true,
            collection: collectionsView.getSelectedCollection()
          };
          break;
        case 'library':
          data = {
            data: true
          };
          break;
        case 'group':
          data = {
            data: true,
            collection: Zotero.Groups.get(collectionsView.getSelectedLibraryID())
          };
      }
      break;
    case 'items':
      data = {
        data: true,
        items: pane.getSelectedItems()
      };
  }
  if (data.data) {
    return this.translate(this.translators.BetterBibTeXJSON.translatorID, data, {
      exportNotes: true,
      exportFileData: false
    }, function(err, references) {
      var params, ww;
      params = {
        wrappedJSObject: {
          references: (err ? null : references)
        }
      };
      ww = Components.classes['@mozilla.org/embedcomp/window-watcher;1'].getService(Components.interfaces.nsIWindowWatcher);
      return ww.openWindow(null, 'chrome://zotero-better-bibtex/content/errorReport.xul', 'zotero-error-report', 'chrome,centerscreen,modal', params);
    });
  } else {
    params = {
      wrappedJSObject: {}
    };
    ww = Components.classes['@mozilla.org/embedcomp/window-watcher;1'].getService(Components.interfaces.nsIWindowWatcher);
    return ww.openWindow(null, 'chrome://zotero-better-bibtex/content/errorReport.xul', 'zotero-error-report', 'chrome,centerscreen,modal', params);
  }
};

Zotero.BetterBibTeX.pref = {};

Zotero.BetterBibTeX.pref.prefs = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefService).getBranch('extensions.zotero.translators.better-bibtex.');

Zotero.BetterBibTeX.pref.observer = {
  register: function() {
    return Zotero.BetterBibTeX.pref.prefs.addObserver('', this, false);
  },
  unregister: function() {
    return Zotero.BetterBibTeX.pref.prefs.removeObserver('', this);
  },
  observe: function(subject, topic, data) {
    switch (data) {
      case 'citekeyFormat':
      case 'citekeyFold':
        Zotero.BetterBibTeX.setCitekeyFormatter();
        Zotero.BetterBibTeX.keymanager.clearDynamic();
        break;
      case 'autoAbbrevStyle':
        Zotero.BetterBibTeX.keymanager.resetJournalAbbrevs();
        break;
      case 'debug':
        Zotero.BetterBibTeX.debugMode();
        return;
    }
    Zotero.BetterBibTeX.cache.reset("pref change: " + data);
    Zotero.BetterBibTeX.auto.reset();
    Zotero.BetterBibTeX.auto.process('preferences change');
    return Zotero.BetterBibTeX.debug('preference change:', subject, topic, data);
  }
};

Zotero.BetterBibTeX.pref.ZoteroObserver = {
  register: function() {
    return Zotero.Prefs.prefBranch.addObserver('', this, false);
  },
  unregister: function() {
    return Zotero.Prefs.prefBranch.removeObserver('', this);
  },
  observe: function(subject, topic, data) {
    var ae, j, len, recursive, ref;
    switch (data) {
      case 'recursiveCollections':
        recursive = !!Zotero.BetterBibTeX.auto.recursive();
        ref = Zotero.BetterBibTeX.DB.autoexport.where(function(o) {
          return !o.exportedRecursively === recursive && o.collection.indexOf('library:') !== 0;
        });
        for (j = 0, len = ref.length; j < len; j++) {
          ae = ref[j];
          ae.exportedRecursively = recursive;
          Zotero.BetterBibTeX.auto.mark(ae, 'pending');
        }
        return Zotero.BetterBibTeX.auto.process("recursive export: " + recursive);
    }
  }
};

Zotero.BetterBibTeX.pref.snapshot = function() {
  var j, key, len, ref, stash;
  stash = Object.create(null);
  ref = this.prefs.getChildList('');
  for (j = 0, len = ref.length; j < len; j++) {
    key = ref[j];
    stash[key] = this.get(key);
  }
  return stash;
};

Zotero.BetterBibTeX.pref.stash = function() {
  return this.stashed = this.snapshot();
};

Zotero.BetterBibTeX.pref.restore = function() {
  var key, ref, ref1, results, value;
  ref1 = (ref = this.stashed) != null ? ref : {};
  results = [];
  for (key in ref1) {
    if (!hasProp.call(ref1, key)) continue;
    value = ref1[key];
    results.push(this.set(key, value));
  }
  return results;
};

Zotero.BetterBibTeX.pref.set = function(key, value) {
  return Zotero.Prefs.set("translators.better-bibtex." + key, value);
};

Zotero.BetterBibTeX.pref.get = function(key) {
  return Zotero.Prefs.get("translators.better-bibtex." + key);
};

Zotero.BetterBibTeX.setCitekeyFormatter = function(enforce) {
  var attempt, attempts, citekeyFormat, citekeyPattern, err, error1, formatter, j, len, msg;
  if (enforce) {
    attempts = ['get', 'reset'];
  } else {
    attempts = ['get'];
  }
  for (j = 0, len = attempts.length; j < len; j++) {
    attempt = attempts[j];
    if (attempt === 'reset') {
      msg = "Malformed citation '" + (this.pref.get('citekeyFormat')) + "' found, resetting to default";
      this.flash(msg);
      this.error(msg);
      this.pref.clearUserPref('citekeyFormat');
    }
    try {
      citekeyPattern = this.pref.get('citekeyFormat');
      citekeyFormat = citekeyPattern.replace(/>.*/, '');
      if (!(citekeyFormat.indexOf('[') >= 0)) {
        throw new Error("no variable parts found in citekey pattern '" + citekeyFormat + "'");
      }
      formatter = new BetterBibTeXPatternFormatter(BetterBibTeXPatternParser.parse(citekeyPattern), this.pref.get('citekeyFold'));
      this.citekeyPattern = citekeyPattern;
      this.citekeyFormat = citekeyFormat;
      this.formatter = formatter;
      return;
    } catch (error1) {
      err = error1;
      this.error(err);
    }
  }
  if (enforce) {
    return this.flash('Citation pattern reset failed! Please report an error to the Better BibTeX issue list.');
  }
};

Zotero.BetterBibTeX.idleService = Components.classes['@mozilla.org/widget/idleservice;1'].getService(Components.interfaces.nsIIdleService);

Zotero.BetterBibTeX.idleObserver = {
  observe: function(subject, topic, data) {
    Zotero.BetterBibTeX.debug("idle: " + topic);
    switch (topic) {
      case 'idle':
        Zotero.BetterBibTeX.auto.idle = true;
        return Zotero.BetterBibTeX.auto.process('idle');
      case 'back':
      case 'active':
        return Zotero.BetterBibTeX.auto.idle = false;
    }
  }
};

Zotero.BetterBibTeX.version = function(version) {
  var v;
  if (!version) {
    return '';
  }
  v = version.split('.').slice(0, 2).join('.');
  this.debug("full version: " + version + ", canonical version: " + v);
  return v;
};

Zotero.BetterBibTeX.migrateData = function() {
  var j, key, len, ref;
  this.DB.SQLite.migrate();
  if (!this.DB.upgradeNeeded) {
    return;
  }
  ref = this.pref.prefs.getChildList('');
  for (j = 0, len = ref.length; j < len; j++) {
    key = ref[j];
    switch (key) {
      case 'auto-abbrev.style':
        this.pref.set('autoAbbrevStyle', this.pref.get(key));
        break;
      case 'auto-abbrev':
        this.pref.set('autoAbbrev', this.pref.get(key));
        break;
      case 'auto-export':
        this.pref.set('autoExport', this.pref.get(key));
        break;
      case 'citeKeyFormat':
        this.pref.set('citekeyFormat', this.pref.get(key));
        break;
      case 'doi-and-url':
        this.pref.set('DOIandURL', this.pref.get(key));
        break;
      case 'key-conflict-policy':
        this.pref.set('keyConflictPolicy', this.pref.get(key));
        break;
      case 'langid':
        this.pref.set('langID', this.pref.get(key));
        break;
      case 'pin-citekeys':
        this.pref.set('pinCitekeys', this.pref.get(key));
        break;
      case 'raw-imports':
        this.pref.set('rawImports', this.pref.get(key));
        break;
      case 'show-citekey':
        this.pref.set('showCitekeys', this.pref.get(key));
        break;
      case 'skipfields':
        this.pref.set('skipFields', this.pref.get(key));
        break;
      case 'unicode':
        this.pref.set('asciiBibTeX', this.pref.get(key) !== 'always');
        this.pref.set('asciiBibLaTeX', this.pref.get(key) === 'never');
        break;
      default:
        continue;
    }
    this.pref.prefs.clearUserPref(key);
  }
  this.pref.prefs.clearUserPref('brace-all');
  this.pref.prefs.clearUserPref('usePrefix');
  this.pref.prefs.clearUserPref('useprefix');
  return this.pref.prefs.clearUserPref('verbatimDate');
};

Zotero.BetterBibTeX.init = function() {
  var endpoint, ep, err, error1, k, loader, months, name, nids, ref, ref1, tests, uninstaller, url;
  if (this.initialized) {
    return;
  }
  this.initialized = true;
  this.testing = this.pref.get('tests') !== '';
  try {
    BetterBibTeXPatternFormatter.prototype.skipWords = this.pref.get('skipWords').split(',');
    Zotero.BetterBibTeX.debug('skipwords:', BetterBibTeXPatternFormatter.prototype.skipWords);
  } catch (error1) {
    err = error1;
    Zotero.BetterBibTeX.error('could not read skipwords:', err);
    BetterBibTeXPatternFormatter.prototype.skipWords = [];
  }
  this.setCitekeyFormatter(true);
  this.debugMode();
  this.translators = Object.create(null);
  this.threadManager = Components.classes['@mozilla.org/thread-manager;1'].getService();
  this.windowMediator = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator);
  this.migrateData();
  if (this.pref.get('scanCitekeys')) {
    this.flash('Citation key rescan', "Scanning 'extra' fields for fixed keys\nFor a large library, this might take a while");
    this.cache.reset('scanCitekeys');
    this.keymanager.reset();
    this.pref.set('scanCitekeys', false);
  }
  Zotero.Translate.Export.prototype.Sandbox.BetterBibTeX = {
    keymanager: {
      months: this.keymanager.months,
      journalAbbrev: (function(_this) {
        return function() {
          var params, sandbox;
          sandbox = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.keymanager.journalAbbrev.apply(_this.keymanager, params);
        };
      })(this),
      extract: (function(_this) {
        return function() {
          var params, sandbox;
          sandbox = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.keymanager.extract.apply(_this.keymanager, params);
        };
      })(this),
      get: (function(_this) {
        return function() {
          var params, sandbox;
          sandbox = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.keymanager.get.apply(_this.keymanager, params);
        };
      })(this),
      alternates: (function(_this) {
        return function() {
          var params, sandbox;
          sandbox = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.keymanager.alternates.apply(_this.keymanager, params);
        };
      })(this),
      cache: (function(_this) {
        return function() {
          var params, sandbox;
          sandbox = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.keymanager.cache.apply(_this.keymanager, params);
        };
      })(this)
    },
    cache: {
      fetch: (function(_this) {
        return function() {
          var params, sandbox;
          sandbox = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.cache.fetch.apply(_this.cache, params);
        };
      })(this),
      store: (function(_this) {
        return function() {
          var params, sandbox;
          sandbox = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.cache.store.apply(_this.cache, params);
        };
      })(this),
      dump: (function(_this) {
        return function() {
          var params, sandbox;
          sandbox = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _this.cache.dump.apply(_this.cache, params);
        };
      })(this),
      stats: function(sandbox) {
        return Zotero.BetterBibTeX.cacheHistory;
      }
    },
    CSL: {
      parseParticles: function(sandbox, name) {
        Zotero.BetterBibTeX.CSL.parseParticles(name);
        return Zotero.BetterBibTeX.CSL.parseParticles(name);
      },
      titleCase: function(sandbox, string) {
        string = string.replace(/\(/g, "(\x02 ");
        string = string.replace(/\)/g, " \x03)");
        string = Zotero.BetterBibTeX.CSL.Output.Formatters.title(Zotero.BetterBibTeX.titleCase.state, string);
        string = string.replace(/\x02 /g, '');
        string = string.replace(/ \x03/g, '');
        return string;
      }
    },
    parseDateToObject: function(sandbox, date, locale) {
      return Zotero.BetterBibTeX.DateParser.prototype.parseDateToObject(date, {
        locale: locale,
        verbatimDetection: true
      });
    },
    parseDateToArray: function(sandbox, date, locale) {
      return Zotero.BetterBibTeX.DateParser.prototype.parseDateToArray(date, {
        locale: locale,
        verbatimDetection: true
      });
    },
    HTMLParser: function(sandbox, html) {
      return Zotero.BetterBibTeX.HTMLParser.parse(html);
    }
  };
  ref = this.endpoints;
  for (name in ref) {
    if (!hasProp.call(ref, name)) continue;
    endpoint = ref[name];
    url = "/better-bibtex/" + name;
    ep = Zotero.Server.Endpoints[url] = function() {};
    ep.prototype = endpoint;
  }
  this.loadTranslators();
  this.extensionConflicts();
  ref1 = Zotero.BetterBibTeX.Locales.months;
  for (k in ref1) {
    months = ref1[k];
    Zotero.BetterBibTeX.CSL.DateParser.addDateParserMonths(months);
  }
  Zotero.Server.DataListener.prototype._generateResponse = (function(original) {
    return function(status, contentType, promise) {
      try {
        if (typeof (promise != null ? promise.then : void 0) === 'function') {
          return promise.then((function(_this) {
            return function(body) {
              if (typeof (body != null ? body.then : void 0) === 'function') {
                throw new Error("Zotero.Server.DataListener::_generateResponse: circular promise!");
              }
              return original.apply(_this, [status, contentType, body]);
            };
          })(this))["catch"]((function(_this) {
            return function(e) {
              return original.apply(_this, [500, 'text/plain', e.message]);
            };
          })(this));
        }
      } catch (undefined) {}
      return original.apply(this, arguments);
    };
  })(Zotero.Server.DataListener.prototype._generateResponse);
  Zotero.Server.DataListener.prototype._requestFinished = (function(original) {
    return function(promise) {
      var error2;
      try {
        if (typeof (promise != null ? promise.then : void 0) === 'function') {
          promise.then((function(_this) {
            return function(response) {
              if (typeof (response != null ? response.then : void 0) === 'function') {
                throw new Error("Zotero.Server.DataListener::_requestFinished: circular promise!");
              }
              return original.apply(_this, [response]);
            };
          })(this))["catch"]((function(_this) {
            return function(e) {
              return original.apply(_this, e.message);
            };
          })(this));
          return;
        }
      } catch (error2) {
        err = error2;
        Zotero.debug("Zotero.Server.DataListener::_requestFinished: error handling promise: " + err.message);
      }
      return original.apply(this, arguments);
    };
  })(Zotero.Server.DataListener.prototype._requestFinished);
  Zotero.Search.prototype.save = (function(original) {
    return function(fixGaps) {
      var id;
      id = original.apply(this, arguments);
      Zotero.BetterBibTeX.auto.markSearch(id);
      return id;
    };
  })(Zotero.Search.prototype.save);
  Zotero.ItemTreeView.prototype.getCellText = (function(original) {
    return function(row, column) {
      var item, key;
      if (column.id === 'zotero-items-column-extra' && Zotero.BetterBibTeX.pref.get('showCitekeys')) {
        item = this._getItemAtRow(row);
        if (!(item != null ? item.ref : void 0) || item.ref.isAttachment() || item.ref.isNote()) {
          return '';
        } else {
          key = Zotero.BetterBibTeX.keymanager.get({
            itemID: item.id
          });
          if (key.citekey.match(/^zotero-(null|[0-9]+)-[0-9]+$/)) {
            return '';
          }
          return key.citekey + (key.citekeyFormat ? ' *' : '');
        }
      }
      return original.apply(this, arguments);
    };
  })(Zotero.ItemTreeView.prototype.getCellText);
  Zotero.Translate.Export.prototype.translate = (function(original) {
    return function() {
      var error2, header, progressWin, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, saved_search, to_export, translatorID;
      Zotero.BetterBibTeX.debug("Zotero.Translate.Export::translate: " + (this._export ? Object.keys(this._export) : 'no @_export'));
      translatorID = (ref2 = this.translator) != null ? ref2[0] : void 0;
      if (translatorID.translatorID) {
        translatorID = translatorID.translatorID;
      }
      Zotero.BetterBibTeX.debug('export: ', translatorID);
      if (!translatorID) {
        return original.apply(this, arguments);
      }
      if ((ref3 = this._export) != null ? (ref4 = ref3.items) != null ? ref4.search : void 0 : void 0) {
        saved_search = this._export.items.search;
        this._export.items = this._export.items.items;
        if (!this._export.items) {
          throw new Error('Cannot export empty search');
        }
      }
      header = Zotero.BetterBibTeX.translators[translatorID];
      if (!(header && ((ref5 = this.location) != null ? ref5.path : void 0))) {
        return original.apply(this, arguments);
      }
      if (this._displayOptions) {
        if (this._displayOptions.exportFileData) {
          this._displayOptions.exportPath = this.location.path;
        } else {
          this._displayOptions.exportPath = this.location.parent.path;
        }
        this._displayOptions.exportFilename = this.location.leafName;
      }
      Zotero.BetterBibTeX.debug("export", this._export, " to " + (((ref6 = this._displayOptions) != null ? ref6.exportFileData : void 0) ? 'directory' : 'file'), this.location.path, 'using', this._displayOptions);
      if (!(((ref7 = this._displayOptions) != null ? ref7['Keep updated'] : void 0) && !this._displayOptions.exportFileData)) {
        return original.apply(this, arguments);
      }
      if (!((ref8 = (ref9 = this._export) != null ? ref9.type : void 0) === 'library' || ref8 === 'collection') && !saved_search) {
        Zotero.BetterBibTeX.flash('Auto-export only supported for searches, groups, collections and libraries');
        return original.apply(this, arguments);
      }
      progressWin = new Zotero.ProgressWindow();
      progressWin.changeHeadline('Auto-export');
      switch (false) {
        case !saved_search:
          progressWin.addLines(["Saved search " + saved_search.name + " set up for auto-export"]);
          to_export = "search:" + saved_search.id;
          break;
        case ((ref10 = this._export) != null ? ref10.type : void 0) !== 'library':
          to_export = this._export.id ? "library:" + this._export.id : 'library';
          try {
            name = Zotero.Libraries.getName(this._export.id);
          } catch (error2) {
            name = to_export;
          }
          progressWin.addLines([name + " set up for auto-export"]);
          break;
        case ((ref11 = this._export) != null ? ref11.type : void 0) !== 'collection':
          progressWin.addLines(["Collection " + this._export.collection.name + " set up for auto-export"]);
          to_export = "collection:" + this._export.collection.id;
          break;
        default:
          progressWin.addLines(['Auto-export only supported for searches, groups, collections and libraries']);
          to_export = null;
      }
      progressWin.show();
      progressWin.startCloseTimer();
      if (to_export) {
        this._displayOptions.translatorID = translatorID;
        Zotero.BetterBibTeX.auto.add(to_export, this.location.path, this._displayOptions);
        Zotero.BetterBibTeX.debug('Captured auto-export:', this.location.path, this._displayOptions);
      }
      return original.apply(this, arguments);
    };
  })(Zotero.Translate.Export.prototype.translate);
  Zotero.Translate.Export.prototype._prepareTranslation = (function(original) {
    return function() {
      var r, ref2, translatorID;
      r = original.apply(this, arguments);
      translatorID = (ref2 = this.translator) != null ? ref2[0] : void 0;
      if (translatorID.translatorID) {
        translatorID = translatorID.translatorID;
      }
      this._itemGetter._BetterBibTeX = Zotero.BetterBibTeX.translators[translatorID];
      this._itemGetter._exportFileData = this._displayOptions.exportFileData;
      return r;
    };
  })(Zotero.Translate.Export.prototype._prepareTranslation);
  Zotero.Translate.ItemGetter.prototype.nextItem = (function(original) {
    return function() {
      var id, item, ref2;
      if (this.legacy || !this._BetterBibTeX) {
        return original.apply(this, arguments);
      }
      if (this._exportFileData) {
        id = (ref2 = this.itemsLeft[0]) != null ? ref2.id : void 0;
        item = original.apply(this, arguments);
        if (item) {
          Zotero.BetterBibTeX.serialized.fixup(item, id);
        }
        return item;
      }
      while (this._itemsLeft.length !== 0) {
        item = Zotero.BetterBibTeX.serialized.get(this._itemsLeft.shift());
        if (!item) {
          continue;
        }
        return item;
      }
      return false;
    };
  })(Zotero.Translate.ItemGetter.prototype.nextItem);
  if (Zotero.ZotFile) {
    Zotero.ZotFile.wildcardTable = (function(original) {
      return function(item) {
        var table;
        table = original.apply(this, arguments);
        if (!(item.isAttachment() || item.isNote())) {
          table['%b'] = Zotero.BetterBibTeX.keymanager.get(item).citekey;
        }
        return table;
      };
    })(Zotero.ZotFile.wildcardTable);
  }
  this.schomd.init();
  this.pref.observer.register();
  this.pref.ZoteroObserver.register();
  Zotero.addShutdownListener(function() {
    Zotero.BetterBibTeX.log('shutting down');
    Zotero.BetterBibTeX.DB.save(true);
    Zotero.BetterBibTeX.debugMode();
  });
  nids = [];
  nids.push(Zotero.Notifier.registerObserver(this.itemChanged, ['item']));
  nids.push(Zotero.Notifier.registerObserver(this.collectionChanged, ['collection']));
  nids.push(Zotero.Notifier.registerObserver(this.itemAdded, ['collection-item']));
  window.addEventListener('unload', (function(e) {
    var id, j, len, results;
    results = [];
    for (j = 0, len = nids.length; j < len; j++) {
      id = nids[j];
      results.push(Zotero.Notifier.unregisterObserver(id));
    }
    return results;
  }), false);
  this.idleService.addIdleObserver(this.idleObserver, this.pref.get('autoExportIdleWait'));
  uninstaller = {
    onUninstalling: function(addon, needsRestart) {
      if (addon.id !== 'better-bibtex@iris-advies.com') {
        return;
      }
      return Zotero.BetterBibTeX.removeTranslators();
    },
    onOperationCancelled: function(addon, needsRestart) {
      if (addon.id !== 'better-bibtex@iris-advies.com') {
        return;
      }
      if (!(addon.pendingOperations & AddonManager.PENDING_UNINSTALL)) {
        return Zotero.BetterBibTeX.loadTranslators();
      }
    }
  };
  AddonManager.addAddonListener(uninstaller);
  if (this.testing) {
    tests = this.pref.get('tests');
    this.pref.set('tests', '');
    try {
      loader = Components.classes['@mozilla.org/moz/jssubscript-loader;1'].getService(Components.interfaces.mozIJSSubScriptLoader);
      loader.loadSubScript("chrome://zotero-better-bibtex/content/test/include.js");
      return this.Test.run(tests.trim().split(/\s+/));
    } catch (undefined) {}
  }
};

Zotero.BetterBibTeX.createFile = function() {
  var f, j, leaf, len, path, paths;
  paths = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  f = Zotero.getZoteroDirectory();
  if (paths.length === 0) {
    throw new Error('no path specified');
  }
  paths.unshift('better-bibtex');
  Zotero.BetterBibTeX.debug('createFile:', paths);
  leaf = paths.pop();
  for (j = 0, len = paths.length; j < len; j++) {
    path = paths[j];
    f.append(path);
    if (!f.exists()) {
      f.create(Components.interfaces.nsIFile.DIRECTORY_TYPE, 0x1ff);
    }
  }
  f.append(leaf);
  return f;
};

Zotero.BetterBibTeX.postscript = "Translator.initialize = (function(original) {\n  return function() {\n    if (this.initialized) {\n      return;\n    }\n    original.apply(this, arguments);\n    try {\n      return Reference.prototype.postscript = new Function(Translator.postscript);\n    } catch (err) {\n      return Translator.debug('postscript failed to compile:', err, Translator.postscript);\n    }\n  };\n})(Translator.initialize);";

Zotero.BetterBibTeX.loadTranslators = function() {
  try {
    this.removeTranslator({
      label: 'Pandoc JSON',
      translatorID: 'f4b52ab0-f878-4556-85a0-c7aeedd09dfc'
    });
  } catch (undefined) {}
  try {
    this.removeTranslator({
      label: 'Better CSL-JSON',
      translatorID: 'f4b52ab0-f878-4556-85a0-c7aeedd09dfc'
    });
  } catch (undefined) {}
  this.load('Better BibTeX', {
    postscript: this.postscript
  });
  this.load('Better BibLaTeX', {
    postscript: this.postscript
  });
  this.load('LaTeX Citation');
  this.load('Pandoc Citation');
  this.load('Better CSL JSON');
  this.load('BetterBibTeX JSON');
  this.load('BibTeXAuxScanner');
  this.load('Collected Notes', {
    target: this.pref.get('collectedNotes')
  });
  try {
    this.removeTranslator({
      label: 'BibTeX Citation Keys',
      translatorID: '0a3d926d-467c-4162-acb6-45bded77edbb'
    });
  } catch (undefined) {}
  try {
    this.removeTranslator({
      label: 'Zotero TestCase',
      translatorID: '82512813-9edb-471c-aebc-eeaaf40c6cf9'
    });
  } catch (undefined) {}
  return Zotero.Translators.init();
};

Zotero.BetterBibTeX.removeTranslators = function() {
  var header, id, ref;
  ref = this.translators;
  for (id in ref) {
    if (!hasProp.call(ref, id)) continue;
    header = ref[id];
    this.removeTranslator(header);
  }
  this.translators = Object.create(null);
  return Zotero.Translators.init();
};

Zotero.BetterBibTeX.removeTranslator = function(header) {
  var destFile, err, error1, fileName;
  try {
    fileName = Zotero.Translators.getFileNameFromLabel(header.label, header.translatorID);
    destFile = Zotero.getTranslatorsDirectory();
    destFile.append(fileName);
    if (destFile.exists()) {
      return destFile.remove(false);
    }
  } catch (error1) {
    err = error1;
    return this.debug("failed to remove " + header.label + ":", err);
  }
};

Zotero.BetterBibTeX.itemAdded = {
  notify: (function(event, type, collection_items) {
    var ae, citekey, collection, collectionID, collection_item, collections, error, error1, extra, found, id, item, itemID, items, j, l, len, len1, missing, note, ref, ref1, ref2, report;
    collections = [];
    items = [];
    if (collection_items.length === 0) {
      return;
    }
    for (j = 0, len = collection_items.length; j < len; j++) {
      collection_item = collection_items[j];
      ref = collection_item.split('-'), collectionID = ref[0], itemID = ref[1];
      collections.push(collectionID);
      items.push(itemID);
      if (event !== 'add') {
        continue;
      }
      collection = Zotero.Collections.get(collectionID);
      if (!collection) {
        continue;
      }
      try {
        extra = JSON.parse(Zotero.Items.get(itemID).getField('extra').trim());
      } catch (error1) {
        error = error1;
        this.debug('no AUX scanner/import error info found on collection add');
        continue;
      }
      note = null;
      switch (extra.translator) {
        case 'ca65189f-8815-4afe-8c8b-8c7c15f0edca':
          if (extra.notimported && extra.notimported.length > 0) {
            report = new this.HTMLNode('http://www.w3.org/1999/xhtml', 'html');
            report.div(function() {
              this.p(function() {
                return this.b('Better BibTeX could not import');
              });
              this.add(' ');
              return this.pre(extra.notimported);
            });
            note = report.serialize();
          }
          break;
        case '0af8f14d-9af7-43d9-a016-3c5df3426c98':
          missing = [];
          ref1 = this.keymanager.resolve(extra.citations, {
            libraryID: collection.libraryID
          });
          for (citekey in ref1) {
            if (!hasProp.call(ref1, citekey)) continue;
            found = ref1[citekey];
            if (found) {
              collection.addItem(found.itemID);
            } else {
              missing.push(citekey);
            }
          }
          if (missing.length !== 0) {
            report = new this.HTMLNode('http://www.w3.org/1999/xhtml', 'html');
            report.div(function() {
              this.p(function() {
                return this.b('BibTeX AUX scan');
              });
              this.p('Missing references:');
              return this.ul(function() {
                var l, len1, results;
                results = [];
                for (l = 0, len1 = missing.length; l < len1; l++) {
                  citekey = missing[l];
                  results.push(this.li(citekey));
                }
                return results;
              });
            });
            note = report.serialize();
          }
      }
      if (note) {
        Zotero.Items.trash([itemID]);
        item = new Zotero.Item('note');
        item.libraryID = collection.libraryID;
        item.setNote(note);
        item.save();
        collection.addItem(item.id);
      }
    }
    if (collections.length !== 0) {
      collections = this.withParentCollections(collections);
    }
    collections = (function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = collections.length; l < len1; l++) {
        id = collections[l];
        results.push("'collection:" + id + "'");
      }
      return results;
    })();
    if (collections.length > 0) {
      ref2 = this.DB.autoexport.where(function(o) {
        var ref2;
        return ref2 = o.collection, indexOf.call(collections, ref2) >= 0;
      });
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        ae = ref2[l];
        this.auto.mark(ae, 'pending');
      }
      return this.auto.process("collection changed: " + collections);
    }
  }).bind(Zotero.BetterBibTeX)
};

Zotero.BetterBibTeX.collectionChanged = {
  notify: function(event, type, ids, extraData) {
    var id;
    if (!(event === 'delete' && extraData.length > 0)) {
      return;
    }
    extraData = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = extraData.length; j < len; j++) {
        id = extraData[j];
        results.push("collection:" + id);
      }
      return results;
    })();
    return this.DB.autoexport.removeWhere(function(o) {
      var ref;
      return ref = o.collection, indexOf.call(extraData, ref) >= 0;
    });
  }
};

Zotero.BetterBibTeX.itemChanged = {
  notify: (function(event, type, ids, extraData) {
    var ae, collections, id, item, j, l, len, len1, len2, len3, len4, libraryID, n, p, parent, parents, q, ref, ref1, ref2, ref3;
    Zotero.BetterBibTeX.debug('itemChanged: event=', event, 'ids=', ids, 'extraData=', extraData);
    if (!(type === 'item' && (event === 'delete' || event === 'trash' || event === 'add' || event === 'modify'))) {
      return;
    }
    if (event === 'delete') {
      ids = extraData;
    }
    if (!(ids.length > 0)) {
      return;
    }
    parents = [];
    ref = Zotero.Items.get(ids);
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      if (item.isAttachment() || item.isNote()) {
        parent = item.getSource();
        if (parent) {
          parents.push(parent);
        }
      }
    }
    if (ids.length > 0) {
      this.keymanager.scan(ids, event);
    }
    if (parents.length > 0) {
      this.keymanager.scan(parents, 'modify');
    }
    Zotero.BetterBibTeX.debug('itemChanged: event=', event, 'ids=', ids, 'parents=', parents);
    ids = (function() {
      var l, len1, ref1, results;
      ref1 = ids.concat(parents);
      results = [];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        id = ref1[l];
        results.push(parseInt(id));
      }
      return results;
    })();
    ids = ids.filter(function(v, i, arr) {
      return arr.indexOf(v) === i;
    });
    if (!(ids.length > 0)) {
      return;
    }
    for (l = 0, len1 = ids.length; l < len1; l++) {
      id = ids[l];
      this.serialized.remove(id);
      this.cache.remove({
        itemID: id
      });
    }
    collections = Zotero.Collections.getCollectionsContainingItems(ids, true) || [];
    if (collections.length !== 0) {
      collections = this.withParentCollections(collections);
    }
    collections = (function() {
      var len2, n, results;
      results = [];
      for (n = 0, len2 = collections.length; n < len2; n++) {
        id = collections[n];
        results.push("collection:" + id);
      }
      return results;
    })();
    ref1 = Zotero.DB.columnQuery("select distinct libraryID from items where itemID in " + (this.DB.SQLite.Set(ids)));
    for (n = 0, len2 = ref1.length; n < len2; n++) {
      libraryID = ref1[n];
      if (libraryID) {
        collections.push("library:" + libraryID);
      } else {
        collections.push('library');
      }
    }
    ref2 = this.DB.autoexport.where(function(o) {
      return o.collection.indexOf('search:') === 0;
    });
    for (p = 0, len3 = ref2.length; p < len3; p++) {
      ae = ref2[p];
      this.auto.markSearch(ae.collection.replace('search:', ''));
    }
    if (collections.length > 0) {
      Zotero.BetterBibTeX.debug('mark:', collections);
      ref3 = this.DB.autoexport.where(function(o) {
        var ref3;
        return ref3 = o.collection, indexOf.call(collections, ref3) >= 0;
      });
      for (q = 0, len4 = ref3.length; q < len4; q++) {
        ae = ref3[q];
        this.auto.mark(ae, 'pending');
      }
      return this.auto.process("items changed: " + collections);
    }
  }).bind(Zotero.BetterBibTeX)
};

Zotero.BetterBibTeX.withParentCollections = function(collections) {
  if (!Zotero.BetterBibTeX.auto.recursive()) {
    return collections;
  }
  if (collections.length === 0) {
    return collections;
  }
  return Zotero.DB.columnQuery("with recursive recursivecollections as ( select collectionID, parentCollectionID from collections where collectionID in " + (Zotero.BetterBibTeX.DB.SQLite.Set(collections)) + " union all select p.collectionID, p.parentCollectionID from collections p join recursivecollections as c on c.parentCollectionID = p.collectionID ) select distinct collectionID from recursivecollections");
};

Zotero.BetterBibTeX.displayOptions = function(url) {
  var hasParams, isBool, j, key, len, params, ref;
  params = {};
  hasParams = false;
  ref = ['exportCharset', 'exportNotes?', 'useJournalAbbreviation?'];
  for (j = 0, len = ref.length; j < len; j++) {
    key = ref[j];
    try {
      isBool = key.match(/[?]$/);
      if (isBool) {
        key = key.replace(isBool[0], '');
      }
      params[key] = url.query[key];
      if (isBool) {
        params[key] = ['y', 'yes', 'true'].indexOf(params[key].toLowerCase()) >= 0;
      }
      hasParams = true;
    } catch (undefined) {}
  }
  if (hasParams) {
    return params;
  }
  return null;
};

Zotero.BetterBibTeX.translate = function(translator, items, displayOptions, callback) {
  var key, translation, value;
  if (!translator) {
    throw 'null translator';
  }
  translation = new Zotero.Translate.Export();
  for (key in items) {
    if (!hasProp.call(items, key)) continue;
    value = items[key];
    switch (key) {
      case 'library':
        translation.setLibraryID(value);
        break;
      case 'items':
        translation.setItems(value);
        break;
      case 'collection':
        translation.setCollection(value);
    }
  }
  translation.setTranslator(translator);
  translation.setDisplayOptions(displayOptions);
  translation.setHandler('done', function(obj, success) {
    return callback(!success, success ? obj != null ? obj.string : void 0 : null);
  });
  return translation.translate();
};

Zotero.BetterBibTeX.getContentsFromURL = function(url) {
  var err, error1;
  try {
    return Zotero.File.getContentsFromURL(url);
  } catch (error1) {
    err = error1;
    throw new Error("Failed to load " + url + ": " + err.msg);
  }
};

Zotero.BetterBibTeX.load = function(translator, options) {
  var code, destFile, err, error1, error2, existing, fileName, header, j, len, metadataJSON, msg, ref, sources, src;
  if (options == null) {
    options = {};
  }
  header = JSON.parse(Zotero.BetterBibTeX.getContentsFromURL("resource://zotero-better-bibtex/translators/" + translator + ".json"));
  this.removeTranslator(header);
  sources = ['json5', 'translator', translator + ".header", translator].concat(((ref = header.BetterBibTeX) != null ? ref.dependencies : void 0) || []);
  this.debug('translator.load:', translator, 'from', sources);
  code = "exports = undefined;\nmodule = undefined;\n";
  for (j = 0, len = sources.length; j < len; j++) {
    src = sources[j];
    try {
      code += Zotero.BetterBibTeX.getContentsFromURL("resource://zotero-better-bibtex/translators/" + src + ".js") + "\n";
    } catch (error1) {
      err = error1;
      this.debug('translator.load: source', src, 'for', translator, 'could not be loaded:', err);
      throw err;
    }
  }
  if (options.postscript) {
    code += options.postscript;
  }
  this.translators[header.translatorID] = this.translators[header.label.replace(/\s/, '')] = header;
  header = JSON.parse(JSON.stringify(header));
  delete header.BetterBibTeX;
  this.debug('Translator.load header:', translator, header);
  try {
    fileName = Zotero.Translators.getFileNameFromLabel(header.label, header.translatorID);
    destFile = Zotero.getTranslatorsDirectory();
    destFile.append(fileName);
    metadataJSON = JSON.stringify(header, null, "\t");
    existing = Zotero.Translators.get(header.translatorID);
    if (existing && destFile.equals(existing.file) && destFile.exists()) {
      msg = "Overwriting translator with same filename '" + fileName + "'";
      Zotero.BetterBibTeX.warn(msg, header);
      Components.utils.reportError(msg + ' in Zotero.BetterBibTeX.load()');
    }
    if (existing && existing.file.exists()) {
      existing.file.remove(false);
    }
    Zotero.BetterBibTeX.log("Saving translator '" + header.label + "'");
    Zotero.File.putContents(destFile, metadataJSON + "\n\n" + code);
    return this.debug('translator.load', translator, 'succeeded');
  } catch (error2) {
    err = error2;
    return this.debug('translator.load', translator, 'failed:', err);
  }
};

Zotero.BetterBibTeX.getTranslator = function(name) {
  var header, id, label, ref, translators;
  if (this.translators[name.replace(/\s/g, '')]) {
    return this.translators[name.replace(/\s/g, '')].translatorID;
  }
  name = name.toLowerCase().replace(/[^a-z]/g, '');
  translators = {};
  ref = this.translators;
  for (id in ref) {
    header = ref[id];
    label = header.label.toLowerCase().replace(/[^a-z]/g, '');
    translators[label] = header.translatorID;
    translators[label.replace(/^zotero/, '')] = header.translatorID;
    translators[label.replace(/^better/, '')] = header.translatorID;
  }
  if (translators[name]) {
    return translators[name];
  }
  throw "No translator " + name + "; available: " + (JSON.stringify(translators)) + " from " + (JSON.stringify(this.translators));
};

Zotero.BetterBibTeX.translatorName = function(id) {
  var ref;
  Zotero.BetterBibTeX.debug('translatorName:', id, 'from', Object.keys(this.translators));
  return ((ref = this.translators[id]) != null ? ref.label : void 0) || ("translator:" + id);
};

Zotero.BetterBibTeX.safeGetAll = function() {
  var all, err, error1;
  try {
    all = Zotero.Items.getAll();
    if (all && !Array.isArray(all)) {
      all = [all];
    }
  } catch (error1) {
    err = error1;
    all = false;
  }
  if (!all) {
    all = [];
  }
  return all;
};

Zotero.BetterBibTeX.safeGet = function(ids) {
  var all;
  if (ids.length === 0) {
    return [];
  }
  all = Zotero.Items.get(ids);
  if (!all) {
    return [];
  }
  return all;
};

Zotero.BetterBibTeX.allowAutoPin = function() {
  return Zotero.Prefs.get('sync.autoSync') || !Zotero.Sync.Server.enabled;
};

Zotero.BetterBibTeX.exportGroup = function() {
  var exporter, group, itemGroup, zoteroPane;
  zoteroPane = Zotero.getActiveZoteroPane();
  itemGroup = zoteroPane.collectionsView._getItemAtRow(zoteroPane.collectionsView.selection.currentIndex);
  if (!itemGroup.isGroup()) {
    return;
  }
  group = Zotero.Groups.get(itemGroup.ref.id);
  if (!Zotero.Items.getAll(false, group.libraryID)) {
    this.flash('Cannot export empty group');
    return;
  }
  exporter = new Zotero_File_Exporter();
  exporter.collection = group;
  exporter.name = group.name;
  return exporter.save();
};

Zotero.BetterBibTeX.XmlNode = (function() {
  function XmlNode(namespace, root, doc1) {
    this.namespace = namespace;
    this.root = root;
    this.doc = doc1;
    if (!this.doc) {
      this.doc = Zotero.BetterBibTeX.document.implementation.createDocument(this.namespace, this.root, null);
      this.root = this.doc.documentElement;
    }
  }

  XmlNode.prototype.serialize = function() {
    return Zotero.BetterBibTeX.serializer.serializeToString(this.doc);
  };

  XmlNode.prototype.alias = function(names) {
    var j, len, name, results;
    results = [];
    for (j = 0, len = names.length; j < len; j++) {
      name = names[j];
      results.push(this.Node.prototype[name] = (function(name) {
        return function() {
          var obj1, v;
          v = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return XmlNode.prototype.add.apply(this, [
            (
              obj1 = {},
              obj1["" + name] = v[0],
              obj1
            )
          ].concat(v.slice(1)));
        };
      })(name));
    }
    return results;
  };

  XmlNode.prototype.set = function() {
    var attr, attrs, j, len, name, node, results, value;
    node = arguments[0], attrs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    results = [];
    for (j = 0, len = attrs.length; j < len; j++) {
      attr = attrs[j];
      results.push((function() {
        var results1;
        results1 = [];
        for (name in attr) {
          if (!hasProp.call(attr, name)) continue;
          value = attr[name];
          switch (false) {
            case typeof value !== 'function':
              results1.push(value.call(new this.Node(this.namespace, node, this.doc)));
              break;
            case name !== '':
              results1.push(node.appendChild(this.doc.createTextNode('' + value)));
              break;
            default:
              results1.push(node.setAttribute(name, '' + value));
          }
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  XmlNode.prototype.add = function() {
    var attrs, c, content, j, len, name, node, ref, results;
    content = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (typeof content[0] === 'object') {
      ref = content[0];
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        attrs = ref[name];
        if (name === '') {
          continue;
        }
        node = this.doc['createElementNS'](this.namespace, name);
        this.root.appendChild(node);
        content = [attrs].concat(content.slice(1));
        break;
      }
    }
    node || (node = this.root);
    content = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = content.length; j < len; j++) {
        c = content[j];
        if (typeof c === 'number' || c) {
          results.push(c);
        }
      }
      return results;
    })();
    results = [];
    for (j = 0, len = content.length; j < len; j++) {
      attrs = content[j];
      switch (false) {
        case typeof attrs !== 'string':
          results.push(node.appendChild(this.doc.createTextNode(attrs)));
          break;
        case typeof attrs !== 'function':
          results.push(attrs.call(new this.Node(this.namespace, node, this.doc)));
          break;
        case !attrs.appendChild:
          results.push(node.appendChild(attrs));
          break;
        default:
          results.push(this.set(node, attrs));
      }
    }
    return results;
  };

  return XmlNode;

})();

Zotero.BetterBibTeX.HTMLNode = (function(superClass) {
  extend(HTMLNode, superClass);

  function HTMLNode(namespace, root, doc1) {
    this.namespace = namespace;
    this.root = root;
    this.doc = doc1;
    HTMLNode.__super__.constructor.call(this, this.namespace, this.root, this.doc);
  }

  HTMLNode.prototype.Node = HTMLNode;

  HTMLNode.prototype.alias(['pre', 'b', 'p', 'div', 'ul', 'li']);

  return HTMLNode;

})(Zotero.BetterBibTeX.XmlNode);
