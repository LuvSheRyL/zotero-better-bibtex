// Generated by CoffeeScript 1.10.0
Components.utils["import"]('resource://gre/modules/Services.jsm');

Zotero.BetterBibTeX.DB = new ((function() {
  _Class.prototype.cacheExpiry = Date.now() - (1000 * 60 * 60 * 24 * 30);

  function _Class() {
    var base, cacheReset, db, idleService, keepCache, volatile;
    this.db = {
      main: new loki('db.json', {
        autosave: true,
        autosaveInterval: 10000,
        adapter: this.adapter,
        env: 'BROWSER'
      }),
      volatile: new loki('cache.json', {
        adapter: this.adapter,
        env: 'BROWSER'
      })
    };
    db = Zotero.BetterBibTeX.createFile('serialized-items.json');
    keepCache = db.exists();
    if (keepCache) {
      db.moveTo(null, this.db.volatile.filename);
    }
    this.db.main.loadDatabase();
    this.db.volatile.loadDatabase();
    this.metadata = this.db.main.getCollection('metadata');
    this.metadata || (this.metadata = this.db.main.addCollection('metadata'));
    this.metadata = this.metadata.chain().data()[0];
    this.metadata || (this.metadata = {});
    delete this.metadata.$loki;
    delete this.metadata.meta;
    (base = this.metadata).cacheReap || (base.cacheReap = Date.now());
    volatile = Zotero.BetterBibTeX.createFile(this.db.volatile.filename);
    if (volatile.exists()) {
      volatile.moveTo(null, this.db.volatile.filename + '.bak');
    }
    this.cache = this.db.volatile.getCollection('cache');
    this.cache || (this.cache = this.db.volatile.addCollection('cache', {
      indices: ['itemID']
    }));
    delete this.cache.binaryIndices.getCollections;
    delete this.cache.binaryIndices.exportCharset;
    delete this.cache.binaryIndices.exportNotes;
    delete this.cache.binaryIndices.translatorID;
    delete this.cache.binaryIndices.useJournalAbbreviation;
    this.cacheAccess = {};
    this.serialized = this.db.volatile.getCollection('serialized');
    this.serialized || (this.serialized = this.db.volatile.addCollection('serialized', {
      indices: ['itemID', 'uri']
    }));
    this.keys = this.db.main.getCollection('keys');
    this.keys || (this.keys = this.db.main.addCollection('keys', {
      indices: ['itemID', 'libraryID', 'citekey']
    }));
    this.autoexport = this.db.main.getCollection('autoexport');
    this.autoexport || (this.autoexport = this.db.main.addCollection('autoexport', {
      indices: ['collection', 'path', 'exportCharset', 'exportNotes', 'translatorID', 'useJournalAbbreviation', 'exportedRecursively']
    }));
    this.upgradeNeeded = this.metadata.Zotero !== ZOTERO_CONFIG.VERSION || this.metadata.BetterBibTeX !== Zotero.BetterBibTeX.release;
    cacheReset = Zotero.BetterBibTeX.pref.get('cacheReset');
    if (!cacheReset) {
      cacheReset = !keepCache && this.metadata.BetterBibTeX && Services.vc.compare(this.metadata.BetterBibTeX, Zotero.BetterBibTeX.release) < 0;
      if (cacheReset && Zotero.BetterBibTeX.pref.get('confirmCacheReset') && (this.cache.chain().data().length > 3000 || this.serialized.chain().data().length > 3000)) {
        cacheReset = confirm(['You have upgraded BetterBibTeX. This usually means output generation for Bib(La)TeX has changed.', 'If you want this change to be applied immediately, you can clear the BibTeX cache. If you have a large library, first (auto)export will be slower than usual', 'If you are in principle satisfied with the output you had, you can just have Better BibTeX replenish the cache as items are changed or added', '', 'Do you want to reset the BibTeX cache now?'].join("\n"));
      }
    }
    if (cacheReset) {
      Zotero.BetterBibTeX.debug('db.reset:', {
        cacheReset: cacheReset,
        keepCache: keepCache,
        db: this.metadata.BetterBibTeX,
        release: Zotero.BetterBibTeX.release
      });
      this.serialized.removeDataOnly();
      this.cache.removeDataOnly();
      if (typeof cacheReset === 'number') {
        cacheReset = cacheReset - 1;
        if (cacheReset < 0) {
          cacheReset = 0;
        }
        Zotero.BetterBibTeX.pref.set('cacheReset', cacheReset);
        Zotero.BetterBibTeX.debug('cache.load forced reset', cacheReset, 'left');
      } else {
        Zotero.BetterBibTeX.debug('cache.load reset after upgrade from', this.metadata.BetterBibTeX, 'to', Zotero.BetterBibTeX.release);
      }
    }
    this.keys.on('insert', (function(_this) {
      return function(key) {
        if (!key.citekeyFormat && Zotero.BetterBibTeX.pref.get('keyConflictPolicy') === 'change') {
          return _this.keys.removeWhere(function(o) {
            return o.citekey === key.citekey && o.libraryID === key.libraryID && o.itemID !== key.itemID && o.citekeyFormat;
          });
        }
      };
    })(this));
    this.keys.on('update', (function(_this) {
      return function(key) {
        if (!key.citekeyFormat && Zotero.BetterBibTeX.pref.get('keyConflictPolicy') === 'change') {
          _this.keys.removeWhere(function(o) {
            return o.citekey === key.citekey && o.libraryID === key.libraryID && o.itemID !== key.itemID && o.citekeyFormat;
          });
        }
        return _this.cache.removeWhere({
          itemID: key.itemID
        });
      };
    })(this));
    this.keys.on('delete', (function(_this) {
      return function(key) {
        return _this.removeWhere({
          itemID: key.itemID
        });
      };
    })(this));
    Zotero.BetterBibTeX.debug('DB: ready');
    Zotero.BetterBibTeX.debug('DB: ready.serialized:', {
      n: this.serialized.chain().data().length
    });
    idleService = Components.classes['@mozilla.org/widget/idleservice;1'].getService(Components.interfaces.nsIIdleService);
    idleService.addIdleObserver({
      observe: (function(_this) {
        return function(subject, topic, data) {
          if (topic === 'idle') {
            return _this.save();
          }
        };
      })(this)
    }, 5);
    Zotero.Notifier.registerObserver({
      notify: function(event, type, ids, extraData) {
        var itemID, j, len, results;
        if (event !== 'delete' && event !== 'trash' && event !== 'modify') {
          return;
        }
        if (event === 'delete') {
          ids = extraData;
        }
        if (!(ids.length > 0)) {
          return;
        }
        results = [];
        for (j = 0, len = ids.length; j < len; j++) {
          itemID = ids[j];
          Zotero.BetterBibTeX.debug('touch:', {
            event: event,
            itemID: itemID
          });
          if (typeof itemID !== 'number') {
            itemID = parseInt(itemID);
          }
          results.push(Zotero.BetterBibTeX.DB.touch(itemID));
        }
        return results;
      }
    }, ['item']);
  }

  _Class.prototype.touch = function(itemID) {
    Zotero.BetterBibTeX.debug('touch:', itemID);
    this.cache.removeWhere({
      itemID: itemID
    });
    this.serialized.removeWhere({
      itemID: itemID
    });
    return this.keys.removeWhere(function(o) {
      return o.itemID === itemID && o.citekeyFormat;
    });
  };

  _Class.prototype.save = function(all) {
    var err, error, error1, error2, id, item, metadata, ref, timestamp;
    Zotero.BetterBibTeX.debug('DB.save:', {
      all: all,
      serialized: this.serialized.chain().data().length
    });
    if (all) {
      try {
        ref = this.cacheAccess;
        for (id in ref) {
          timestamp = ref[id];
          item = this.cache.get(id);
          if (!item) {
            next;
          }
          item.accessed = timestamp;
          this.cache.update(item);
        }
        if (this.metadata.cacheReap < this.cacheExpiry) {
          this.metadata.cacheReap = Date.now();
          this.cache.removeWhere((function(_this) {
            return function(o) {
              return (o.accessed || 0) < _this.cacheExpiry;
            };
          })(this));
        }
      } catch (error) {
        err = error;
        Zotero.BetterBibTeX.error('error purging cache:', err);
      }
      try {
        this.db.volatile.save(function(err) {
          if (err) {
            Zotero.BetterBibTeX.error('error saving cache:', err);
            throw err;
          }
        });
      } catch (error1) {
        err = error1;
        Zotero.BetterBibTeX.error('error saving cache:', err);
      }
    }
    if (all || this.db.main.autosaveDirty()) {
      try {
        this.metadata.Zotero = ZOTERO_CONFIG.VERSION;
        this.metadata.BetterBibTeX = Zotero.BetterBibTeX.release;
        this.db.main.removeCollection('metadata');
        metadata = this.db.main.addCollection('metadata');
        metadata.insert(this.metadata);
      } catch (error2) {
        err = error2;
        Zotero.BetterBibTeX.error('error updating DB metadata:', err);
      }
      this.db.main.save(function(err) {
        if (err) {
          Zotero.BetterBibTeX.error('error saving DB:', err);
          throw err;
        }
      });
      return this.db.main.autosaveClearFlags();
    }
  };

  _Class.prototype.adapter = {
    saveDatabase: function(name, serialized, callback) {
      var file;
      file = Zotero.BetterBibTeX.createFile(name);
      Zotero.File.putContents(file, serialized);
      callback();
      return Zotero.BetterBibTeX.debug('DB.saveDatabase:', {
        name: name,
        file: file.path
      });
    },
    loadDatabase: function(name, callback) {
      var file;
      file = Zotero.BetterBibTeX.createFile(name);
      Zotero.BetterBibTeX.debug('DB.loadDatabase:', {
        name: name,
        file: file.path
      });
      if (file.exists()) {
        callback(Zotero.File.getContents(file));
      } else {
        callback(null);
      }
      return Zotero.BetterBibTeX.debug('DB.loadDatabase: done', {
        name: name,
        file: file.path
      });
    }
  };

  _Class.prototype.SQLite = {
    parseTable: function(name) {
      var schema;
      name = name.split('.');
      switch (name.length) {
        case 1:
          schema = '';
          name = name[0];
          break;
        case 2:
          schema = name[0] + '.';
          name = name[1];
      }
      if (name[0] === '"') {
        name = name.slice(1, -1);
      }
      return {
        schema: schema,
        name: name
      };
    },
    table_info: function(table) {
      var column, columns, fields, i, j, len, name, statement, values;
      table = this.parseTable(table);
      statement = Zotero.DB.getStatement("pragma " + table.schema + "table_info(\"" + table.name + "\")", null, true);
      fields = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = statement.columnCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(statement.getColumnName(i).toLowerCase());
        }
        return results;
      })();
      columns = {};
      while (statement.executeStep()) {
        values = (function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = statement.columnCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(Zotero.DB._getTypedValue(statement, i));
          }
          return results;
        })();
        column = {};
        for (i = j = 0, len = fields.length; j < len; i = ++j) {
          name = fields[i];
          column[name] = values[i];
        }
        columns[column.name] = column;
      }
      statement.finalize();
      return columns;
    },
    columnNames: function(table) {
      return Object.keys(this.table_info(table));
    },
    tableExists: function(name) {
      var table;
      table = this.parseTable(name);
      return Zotero.DB.valueQuery("SELECT count(*) FROM " + table.schema + "sqlite_master WHERE type='table' and name=?", [table.name]) !== 0;
    },
    Set: function(values) {
      var v;
      return '(' + ((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = values.length; j < len; j++) {
          v = values[j];
          results.push('' + v);
        }
        return results;
      })()).join(', ') + ')';
    },
    migrate: function() {
      var db, j, k, l, len, len1, len2, migrated, pinned, ref, ref1, ref2, row;
      db = Zotero.getZoteroDatabase('betterbibtexcache');
      if (db.exists()) {
        db.remove(true);
      }
      db = Zotero.BetterBibTeX.createFile('better-bibtex-serialized-items.json');
      if (db.exists()) {
        db.remove(true);
      }
      db = Zotero.getZoteroDatabase('betterbibtex');
      if (!db.exists()) {
        return;
      }
      Zotero.BetterBibTeX.flash('Better BibTeX: updating database', 'Updating database, this could take a while');
      Zotero.DB.query('ATTACH ? AS betterbibtex', [db.path]);
      if (this.tableExists('betterbibtex.autoexport') && !this.table_info('betterbibtex.autoexport').context) {
        Zotero.BetterBibTeX.debug('DB.migrate: autoexport');
        Zotero.BetterBibTeX.DB.autoexport.removeDataOnly();
        if (this.table_info('betterbibtex.autoexport').collection) {
          Zotero.DB.query("update betterbibtex.autoexport set collection = (select 'library:' || libraryID from groups where 'group:' || groupID = collection) where collection like 'group:%'");
          Zotero.DB.query("update betterbibtex.autoexport set collection = 'collection:' || collection where collection <> 'library' and collection not like '%:%'");
        }
        migrated = 0;
        ref = Zotero.DB.query('select * from betterbibtex.autoexport');
        for (j = 0, len = ref.length; j < len; j++) {
          row = ref[j];
          migrated += 1;
          Zotero.BetterBibTeX.DB.autoexport.insert({
            collection: row.collection,
            path: row.path,
            exportCharset: row.exportCharset,
            exportNotes: row.exportNotes === 'true',
            translatorID: row.translatorID,
            useJournalAbbreviation: row.useJournalAbbreviation === 'true',
            exportedRecursively: row.exportedRecursively === 'true',
            status: 'pending'
          });
        }
        Zotero.BetterBibTeX.debug('DB.migrate: autoexport=', migrated);
      }
      if (this.tableExists('betterbibtex.cache')) {
        Zotero.BetterBibTeX.debug('DB.migrate: cache');
        Zotero.BetterBibTeX.DB.cache.removeDataOnly();
        migrated = 0;
        ref1 = Zotero.DB.query('select * from betterbibtex.cache');
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          row = ref1[k];
          migrated += 1;
          Zotero.BetterBibTeX.DB.cache.insert({
            itemID: parseInt(row.itemID),
            exportCharset: row.exportCharset,
            exportNotes: row.exportNotes === 'true',
            translatorID: row.translatorID,
            useJournalAbbreviation: row.useJournalAbbreviation === 'true',
            citekey: row.citekey,
            bibtex: row.bibtex,
            accessed: Date.now()
          });
        }
        Zotero.BetterBibTeX.debug('DB.migrate: cache=', migrated);
      }
      if (this.tableExists('betterbibtex.keys')) {
        Zotero.BetterBibTeX.debug('DB.migrate: keys');
        Zotero.BetterBibTeX.DB.keys.removeDataOnly();
        pinned = this.table_info('betterbibtex.autoexport').pinned;
        migrated = 0;
        ref2 = Zotero.DB.query('select k.*, i.libraryID from betterbibtex.keys k join items i on k.itemID = i.itemID');
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          row = ref2[l];
          if (pinned && row.pinned !== 1) {
            continue;
          }
          migrated += 1;
          if (!row.citekeyFormat) {
            row.citekeyFormat = null;
          }
          Zotero.BetterBibTeX.DB.keys.insert({
            itemID: parseInt(row.itemID),
            citekey: row.citekey,
            citekeyFormat: row.citekeyFormat,
            libraryID: row.libraryID
          });
        }
        Zotero.BetterBibTeX.debug('DB.migrate: keys=', migrated);
      }
      Zotero.DB.query('DETACH betterbibtex');
      db.moveTo(null, 'betterbibtex.sqlite.bak');
      Zotero.BetterBibTeX.DB.save(true);
      Zotero.BetterBibTeX.flash('Better BibTeX: database updated', 'Database update finished');
      return Zotero.BetterBibTeX.flash('Better BibTeX: cache has been reset', 'Cache has been reset due to a version upgrade. First exports after upgrade will be slower than usual');
    }
  };

  return _Class;

})());
